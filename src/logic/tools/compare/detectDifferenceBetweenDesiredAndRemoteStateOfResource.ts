import { DetailedDiff, detailedDiff as objectDiff } from 'deep-object-diff';
import { DomainObject, omitMetadataValues } from 'domain-objects';
import { diff as jestDiff } from 'jest-diff';
import { VisualogicContext } from 'visualogic';

import { DeclaredResource } from '../../../domain/DeclaredResource';
import { DeclaredResourceReference } from '../../../domain/DeclaredResourceReference';
import { DeclastructContext } from '../../../domain/DeclastructContext';
import { castReferenceToGrokableString } from './castReferenceToGrokableString';

/**
 * recursively traverse each key of the object and grokify any references found
 */
const withReferencesGrokified = async (
  { resource }: { resource: DeclaredResource },
  context: DeclastructContext & VisualogicContext,
) => {
  // create a clone of the resources, which we'll mutate keys on
  const withKeysGrokified: Record<string, any> =
    new (resource.constructor as typeof DomainObject)(resource);

  // for each key holding a reference, replace reference with grokable string
  await Promise.all(
    Object.keys(resource).map(async (key) => {
      const value = (resource as any)[key];
      if (value instanceof DeclaredResourceReference)
        withKeysGrokified[key] = await castReferenceToGrokableString(
          { reference: value },
          context,
        );
      else if (Array.isArray(value))
        withKeysGrokified[key] = await Promise.all(
          value.map(async (valueItem) =>
            value instanceof DeclaredResourceReference
              ? await castReferenceToGrokableString(
                  { reference: valueItem },
                  context,
                )
              : await withReferencesGrokified({ resource: valueItem }, context),
          ),
        );
      else if (value instanceof DomainObject)
        withKeysGrokified[key] = await withReferencesGrokified(
          { resource: value },
          context,
        );
    }),
  );

  // return the fingerprinted object
  return withKeysGrokified;
};

export const detectDifferenceBetweenDesiredAndRemoteStateOfResource = async <
  T extends DomainObject<any>,
>(
  {
    desiredState,
    remoteState,
  }: {
    desiredState: T | null;
    remoteState: T | null;
  },
  context: DeclastructContext & VisualogicContext,
): Promise<{
  displayable: string;
  usable: DetailedDiff;
}> => {
  // replace all nested references with reference fingerprints, for readability
  const diffableDesiredState = desiredState
    ? // remove the metadata values from the desired state for diff, since these properties dont describe the data, they are just additional data typically generated by the remote state which cant be locally declared (e.g., uuid, createdAt, etc)
      omitMetadataValues(
        await withReferencesGrokified({ resource: desiredState }, context),
      )
    : null;
  const diffableRemoteState = remoteState
    ? // remove the metadata values from the remote state for diff, since these properties dont describe the data, they are just additional data typically generated by the remote state which cant be locally declared (e.g., uuid, createdAt, etc)
      omitMetadataValues(
        await withReferencesGrokified({ resource: remoteState }, context),
      )
    : null;

  // define a displayable difference
  const displayableDifference: string = jestDiff(
    diffableDesiredState ?? {},
    diffableRemoteState ?? {},
    {
      omitAnnotationLines: true,
      aAnnotation: 'Desired State',
      bAnnotation: 'Remote State',
      aIndicator: '+',
      bIndicator: '-',
    },
  )!;

  // replace the "Object {}" placeholder we have to use to represent null state, if present (since jest shows "Comparing two different types of values. Expected object but received null." if we try to use null directly)
  const cleanedDisplayableDifference = displayableDifference
    ?.replace('- Object {}', '- null')
    .replace('+ Object {}', '+ null');

  // define a usable difference
  const usableDifference = objectDiff(
    diffableRemoteState ?? {},
    diffableDesiredState ?? {},
  ); // TODO: improve the usable difference. use the `objectDiff` and add our own info + make a more useful type

  // return both
  return {
    displayable: cleanedDisplayableDifference,
    usable: usableDifference,
  };
};
