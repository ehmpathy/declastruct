# blueprint: `--plan yolo` for one-line applies

## context

the wish described in `0.wish.md` wants to enable:

```sh
npx declastruct apply --wish .agent/repo=.this/skills/use.vpc.ts --plan yolo
```

this would skip the normal two-step flow (plan â†’ apply) and go directly from wish â†’ apply.

---

## current flow

today the flow is:

1. **plan**: `declastruct plan --wish <file> --into <plan.json>`
   - imports wish file
   - calls `planChanges()` to compute changes
   - writes plan to json file

2. **apply**: `declastruct apply --plan <plan.json>`
   - loads plan from json
   - imports wish file from `plan.wish.uri`
   - calls `applyChanges()` which:
     - replans to validate plan is still fresh (calls `planChanges()`)
     - calls `assertPlanStillValid()` to compare hashes
     - applies each change

the validation step in `applyChanges` exists to catch drift between plan creation and apply time.

---

## proposed change

add `--plan yolo` mode that:
- takes `--wish` directly (like plan command)
- skips plan file persistence
- skips staleness validation
- applies immediately

---

## implementation blueprint

### 1. modify CLI (`src/contract/cli/invoke.ts`)

add `--wish` option to apply command and route based on `--plan` value:

```ts
program
  .command('apply')
  .description('Apply changes from a plan file')
  .option('--plan <file>', 'Path to plan file, or "yolo" for immediate apply')
  .option('--wish <file>', 'Path to wish file (required when --plan yolo)')
  .action(async (options) => {
    try {
      await executeApplyCommand({
        planFilePath: options.plan,
        wishFilePath: options.wish,
      });
    } catch (error) {
      log.error('âœ– Error during apply:', error);
      process.exit(1);
    }
  });
```

### 2. make `executeApplyCommand` generic (`src/contract/cli/apply.ts`)

refactor to handle both modes via input shape:

```ts
/**
 * .what = executes the apply command to apply infrastructure changes
 * .why = provides CLI interface for applying infrastructure changes
 * .note = supports two modes:
 *   - standard: load plan from file, validate staleness, apply
 *   - yolo: plan from wish directly, skip validation, apply immediately
 */
export const executeApplyCommand = async (
  input: {
    planFilePath?: string;
    wishFilePath?: string;
  },
): Promise<void> => {
  // determine mode and validate input
  const isYoloMode = input.planFilePath === 'yolo';

  if (isYoloMode) {
    // yolo mode requires --wish
    if (!input.wishFilePath) {
      throw new BadRequestError('--wish required when --plan yolo');
    }
  } else {
    // standard mode requires --plan (not "yolo")
    if (!input.planFilePath) {
      throw new BadRequestError('--plan required');
    }
  }

  // resolve wish path (from input or from plan file)
  const resolvedWishPath = isYoloMode
    ? resolve(process.cwd(), input.wishFilePath!)
    : null; // will be loaded from plan

  // resolve plan path (null for yolo mode)
  const resolvedPlanPath = isYoloMode
    ? null
    : resolve(process.cwd(), input.planFilePath!);

  // load plan from file (standard mode only)
  let plan: DeclastructPlan | null = null;
  if (resolvedPlanPath) {
    if (!existsSync(resolvedPlanPath)) {
      throw new BadRequestError(`Plan file not found: ${resolvedPlanPath}`);
    }
    const planJson = await readFile(resolvedPlanPath, 'utf-8');
    plan = new DeclastructPlan(JSON.parse(planJson));
  }

  // determine wish path
  const wishPath = resolvedWishPath ?? plan!.wish.uri;

  // validate wish file exists
  if (!existsSync(wishPath)) {
    throw new BadRequestError(`Wish file not found: ${wishPath}`);
  }

  // log header
  log.info(`ðŸŒŠ declastruct apply${isYoloMode ? ' (yolo)' : ''}`);
  if (resolvedPlanPath) log.info(`   plan: ${resolvedPlanPath}`);
  log.info(`   wish: ${wishPath}`);
  log.info('');

  // import wish file
  const wish = await import(wishPath);

  // validate exports
  if (typeof wish.getResources !== 'function') {
    throw new BadRequestError('Wish file must export getResources() function');
  }
  if (typeof wish.getProviders !== 'function') {
    throw new BadRequestError('Wish file must export getProviders() function');
  }

  // get resources and providers
  const resources = await wish.getResources();
  const providers = await wish.getProviders();

  // initialize providers
  log.info('âœ¨ start providers...');
  await Promise.all(providers.map((p: any) => p.hooks.beforeAll()));

  // create context
  const context = {
    bottleneck: new Bottleneck({ maxConcurrent: 1 }),
    log,
  };

  // apply changes (plan=null triggers yolo mode, skipping validation)
  const result = await applyChanges(
    {
      plan,
      resources,
      providers,
      wishFilePath: wishPath,
    },
    context,
  );

  // cleanup providers
  log.info('');
  log.info('âœ¨ stop providers...');
  await Promise.all(providers.map((p: any) => p.hooks.afterAll()));

  // log summary
  log.info('');
  log.info(`ðŸŒŠ applied ${result.appliedChanges.length} changes`);
  log.info('');
};
```

### 3. refactor `applyChanges` to accept nullable plan (`src/domain.operations/apply/applyChanges.ts`)

make `plan` nullable - when null, skip validation (yolo mode):

```ts
/**
 * .what = applies changes to achieve desired state
 * .why = executes infrastructure changes in a controlled, observable manner
 * .note = idempotent - reapplying same plan is safe
 */
export const applyChanges = async (
  input: {
    plan: DeclastructPlan | null;
    resources: DomainEntity<any>[];
    providers: DeclastructProvider<any, any>[];
    wishFilePath: string;
  },
  context: ContextLogTrail & ContextDeclastruct,
): Promise<{ appliedChanges: DeclastructChange[] }> => {
  // replan to get current state
  const currentPlan = await planChanges(
    {
      resources: input.resources,
      providers: input.providers,
      wishFilePath: input.wishFilePath,
    },
    context,
  );

  // validate plan matches current state (skip if no plan provided, i.e. yolo mode)
  if (input.plan) {
    assertPlanStillValid({
      originalPlan: input.plan,
      currentPlan,
    });
    context.log.info('');
    context.log.info('ðŸ‘Œ plan still valid...');
  } else {
    context.log.info('');
    context.log.info('ðŸ¤™ yolo, plan not reviewed...');
  }

  // use current plan for apply (works for both modes)
  const planToApply = currentPlan;

  // log apply phase header
  const isYoloMode = !input.plan;
  context.log.info('');
  context.log.info(`ðŸª„  apply changes${isYoloMode ? ' (yolo)' : ''}...`);
  context.log.info('');

  // apply each change with real-time logging
  const appliedChanges: DeclastructChange[] = [];

  for (const change of planToApply.changes) {
    // log KEEP actions and skip
    if (change.action === DeclastructChangeAction.KEEP) {
      context.log.info(`â†“ [KEEP] ${change.forResource.slug}`, {});
      continue;
    }

    // find the desired resource
    const resourceFound =
      input.resources.find(
        (candidate) =>
          candidate.constructor.name === change.forResource.class &&
          getUniqueIdentifierSlug(candidate) === change.forResource.slug,
      ) ??
      UnexpectedCodePathError.throw(
        'could not find resource specified in plan. was it removed?',
        { change },
      );

    // apply the change
    const applied = await applyChange({
      change,
      resource: resourceFound,
      providers: input.providers,
    });

    // log success immediately
    context.log.info(`âœ” [${applied.action}] ${applied.forResource.slug}`, {});

    appliedChanges.push(applied);
  }

  return { appliedChanges };
};
```

---

## files to modify

1. **modify**: `src/contract/cli/invoke.ts` - add `--wish` option to apply command
2. **modify**: `src/contract/cli/apply.ts` - make `executeApplyCommand` handle both modes
3. **modify**: `src/domain.operations/apply/applyChanges.ts` - add `skipValidation` flag
4. **modify**: integration tests to cover yolo mode

---

## test cases

1. `apply --plan yolo --wish <valid>` â†’ plans and applies successfully
2. `apply --plan yolo` (no wish) â†’ error: wish required
3. `apply` (no plan, no wish) â†’ error: plan required
4. `apply --plan yolo --wish <nonexistent>` â†’ error: file not found
5. `apply --plan yolo --wish <invalid-exports>` â†’ error: missing getResources/getProviders
6. yolo mode should apply changes without staleness check
7. standard mode should still validate plan staleness
8. yolo mode should handle KEEP, CREATE, UPDATE, DELETE actions

---

## usage example

```sh
# standard two-step flow (with review)
npx declastruct plan --wish ./wish.ts --into ./plan.json
# ... review plan.json ...
npx declastruct apply --plan ./plan.json

# yolo mode (one-liner for trusted scenarios)
npx declastruct apply --wish ./wish.ts --plan yolo
```
