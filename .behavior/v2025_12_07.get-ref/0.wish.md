wish =

the declastruct daos should make it easy to resolve refs into the desired version

e.g.,

given
- input = Ref<typeof DeclaredResource>
- needed = RefByPrimary<typeof DeclaredResource>

then,
- should be able to call daoDeclaredResource.getRef.byPrimary(input) => RefByPrimary<typeof DeclaredResource>
since the dao already has `getOne({ by: { unique, primary }})`, then inside

daoDeclaredResource.getRef.byPrimary = async (input: Ref<typeof DeclaredResource>, context) => {
  // if already given a refByPrimary, use it
  if (isRefByPrimary({ of: DeclaredResource })(input)) return input

  // if given refByUnique, get the resource and cast to ref
  if (isRefByUnique({ of: DeclaredResource })(input)) {
    const found = await daoDeclaredResource.get({ by: { unique: input } }, context);
    if (!found) throw new BadRequestError('cant refByPrimary an entity that cant be found via refByUnique', { input })
    return refByPrimary<typeof DeclaredResource>(found)
  }

  // otheriwse, unsupported input; Ref constrains to refByUnique or refByPrimary, so something went wrong at runtime
  throw new UnexpectedCodePathError('was given a ref that was neither refByUnique nor refByPrimary', { input })
}


---

that way, it makes it easy to work with dobjs that have attributes which are Ref, rather than RefByUnique/RefByPrimary specifically

---

the reason we want to support this flow is because it makes it easier to compose and reuse dobjs efficiently. some requests may only know refByPrimary or refByUnique; we shouldn't require hydration and should allow a generic Ref instead, casue we can always hydrate when needed (and often times, whatever was known is more than sufficient!)
