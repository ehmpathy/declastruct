# Blueprint: getRef Convenience Methods for DeclastructDao

## Overview

this blueprint outlines the implementation of `getRef` convenience methods on `DeclastructDao` - enabling easy resolution of `Ref<TResourceClass>` into `RefByPrimary<TResourceClass>` or `RefByUnique<TResourceClass>`.

## Wish Summary

given
- input = `Ref<typeof DeclaredResource>` (could be refByPrimary OR refByUnique)
- needed = `RefByPrimary<typeof DeclaredResource>` (specifically need the primary key)

then
- call `dao.get.ref.byPrimary(input)` => `RefByPrimary<typeof DeclaredResource>`

this enables ergonomic composition of domain objects that reference each other via generic `Ref` types, while still being able to resolve to specific ref types when needed.

## Core Design

### Approach: Restructure DeclastructDao Interface

1. add `dobj` attribute to carry the resource class
2. restructure `get` to separate `one` (fetch resource) from `ref` (resolve reference)

```typescript
export interface DeclastructDao<
  TResource extends DomainEntity<any>,
  TResourceClass extends Refable<any, any, any>,
  TContext = never,
> {
  /**
   * .what = the domain object class this dao operates on
   * .why = enables downstream operations (like getRefByPrimary) to access static properties
   */
  dobj: TResourceClass;

  get: {
    /**
     * .what = fetch a single resource
     */
    one: {
      byUnique(...): Promise<TResource | null>;  // required
      byPrimary: null | ((...) => Promise<TResource | null>); // null if no primary keys
      byRef(...): Promise<TResource | null>;      // required
    };

    /**
     * .what = ref resolution utilities for converting between ref types
     * .why = enables working with generic Ref<T> while resolving to specific RefByPrimary/RefByUnique when needed
     *
     * .note = set methods to null if resource lacks primary keys (forces explicit decision)
     */
    ref: {
      /**
       * resolve any ref to RefByPrimary
       *
       * .note
       *   - set to null if resource lacks primary keys
       *   - if already RefByPrimary, returns as-is (no db call)
       *   - if RefByUnique, fetches resource and extracts primary key
       *   - throws BadRequestError if resource not found
       */
      byPrimary:
        | null
        | ((
            input: Ref<TResourceClass>,
            context: TContext,
          ) => Promise<RefByPrimary<TResourceClass>>);

      /**
       * resolve any ref to RefByUnique
       *
       * .note
       *   - set to null if resource lacks primary keys
       *   - if already RefByUnique, returns as-is (no db call)
       *   - if RefByPrimary, fetches resource and extracts unique key
       *   - throws BadRequestError if resource not found
       */
      byUnique:
        | null
        | ((
            input: Ref<TResourceClass>,
            context: TContext,
          ) => Promise<RefByUnique<TResourceClass>>);
    };
  };
  set: { ... };  // existing
}
```

### Implementation Pattern

following the pattern from the wish, with minimal dao dependency via context. the dao carries its `dobj` (resource class), so callers don't need to pass it separately:

```typescript
/**
 * .what = resolves any ref to RefByPrimary for a given resource class
 * .why = enables converting generic Ref to specific RefByPrimary without manual checks
 */
export const getRefByPrimary = async <
  TResource extends DomainEntity<any>,
  TResourceClass extends Refable<any, any, any>,
>(
  input: {
    ref: Ref<TResourceClass>;
  },
  context: {
    dao: {
      dobj: TResourceClass;
      get: { one: { byUnique: (ref: RefByUnique<TResourceClass>) => Promise<TResource | null> } };
    };
  },
): Promise<RefByPrimary<TResourceClass>> => {
  // if already given a refByPrimary, use it (no db call needed)
  if (isRefByPrimary({ of: context.dao.dobj })(input.ref)) return input.ref;

  // if given refByUnique, get the resource and cast to ref
  if (isRefByUnique({ of: context.dao.dobj })(input.ref)) {
    const found = await context.dao.get.one.byUnique(input.ref);
    if (!found)
      throw new BadRequestError(
        'cannot resolve refByPrimary: entity not found via refByUnique',
        { ref: input.ref },
      );
    return refByPrimary({ of: context.dao.dobj })(found);
  }

  // otherwise, unexpected input; Ref constrains to refByUnique or refByPrimary
  throw new UnexpectedCodePathError(
    'ref was neither refByUnique nor refByPrimary',
    { ref: input.ref },
  );
};
```

### Helper Utilities

create standalone utilities that can be used to implement the dao methods:

```
src/
└── domain.operations/
    └── ref/
        ├── getRefByPrimary.ts
        ├── getRefByPrimary.test.ts
        ├── getRefByUnique.ts
        └── getRefByUnique.test.ts
```

## Domain Model Changes

### DeclastructDao Interface Update (BREAKING CHANGE)

this is a breaking change to the `DeclastructDao` interface:
1. add `dobj` attribute to carry the resource class
2. restructure `get` from flat methods to nested `one` and `ref` namespaces

**before:**
```typescript
dao.get.byUnique(...)
dao.get.byPrimary(...)
dao.get.byRef(...)
```

**after:**
```typescript
dao.dobj                    // NEW - the resource class
dao.get.one.byUnique(...)
dao.get.one.byPrimary(...)
dao.get.one.byRef(...)
dao.get.ref.byPrimary(...)  // NEW
dao.get.ref.byUnique(...)   // NEW
```

```typescript
// src/domain.objects/DeclastructDao.ts

import {
  type DomainEntity,
  DomainLiteral,
  type Ref,
  type Refable,
  type RefByPrimary,
  type RefByUnique,
} from 'domain-objects';
import type { HasMetadata } from 'type-fns';

export interface DeclastructDao<
  TResource extends DomainEntity<any>,
  TResourceClass extends Refable<any, any, any>,
  TContext = never,
> {
  /**
   * .what = the domain object class this dao operates on
   * .why = enables downstream operations (like getRefByPrimary) to access static properties
   */
  dobj: TResourceClass;

  /**
   * .what = read operations for fetching resources and resolving refs
   * .why = provides consistent, type-safe access to remote state
   */
  get: {
    /**
     * .what = fetch a single resource by reference
     * .why = enables looking up current state of a resource
     */
    one: {
      /**
       * .what = fetch by unique keys
       * .why = enables idempotent lookups via natural keys
       */
      byUnique(
        input: RefByUnique<TResourceClass>,
        context: TContext,
      ): Promise<TResource | null>;

      /**
       * .what = fetch by primary keys
       * .why = enables efficient lookups when primary key is known
       *
       * .note = set to null if resource lacks primary keys (forces explicit decision)
       */
      byPrimary:
        | null
        | ((
            input: RefByPrimary<TResourceClass>,
            context: TContext,
          ) => Promise<TResource | null>);

      /**
       * .what = fetch by any supported reference type
       * .why = enables flexible lookups when ref type is not known at compile time
       */
      byRef(
        input: Ref<TResourceClass>,
        context: TContext,
      ): Promise<TResource | null>;
    };

    /**
     * .what = ref resolution utilities for converting between ref types
     * .why = enables working with generic Ref<T> while resolving to specific RefByPrimary/RefByUnique when needed
     *
     * .note
     *   - set methods to null if resource lacks primary keys (forces explicit decision)
     *   - implementers can use the helper utilities from domain.operations/ref/
     */
    ref: {
      /**
       * .what = resolve any ref to RefByPrimary
       * .why = enables getting primary key from any ref type
       *
       * .note = set to null if resource lacks primary keys
       */
      byPrimary:
        | null
        | ((
            input: Ref<TResourceClass>,
            context: TContext,
          ) => Promise<RefByPrimary<TResourceClass>>);

      /**
       * .what = resolve any ref to RefByUnique
       * .why = enables getting unique key from any ref type
       *
       * .note = set to null if resource lacks primary keys
       */
      byUnique:
        | null
        | ((
            input: Ref<TResourceClass>,
            context: TContext,
          ) => Promise<RefByUnique<TResourceClass>>);
    };
  };

  /**
   * .what = write operations for mutating resources
   * .why = provides idempotent, type-safe mutations to remote state
   */
  set: {
    /**
     * .what = find or insert resource
     * .why = idempotent create - returns existing if found by unique keys, otherwise creates
     */
    findsert(
      input: TResource,
      context: TContext,
    ): Promise<HasMetadata<TResource>>;

    /**
     * .what = create or update resource
     * .why = idempotent upsert - creates if not found, updates if found
     *
     * .note = optional, only if resource supports updates
     */
    upsert?(
      input: TResource,
      context: TContext,
    ): Promise<HasMetadata<TResource>>;

    /**
     * .what = delete resource
     * .why = removes resource from remote state
     *
     * .note = optional, only if resource supports deletion
     */
    delete?(input: Ref<TResourceClass>, context: TContext): Promise<void>;
  };
}
```

## Domain Operations

### getRefByPrimary

```typescript
// src/domain.operations/ref/getRefByPrimary.ts

import {
  type DomainEntity,
  type Ref,
  type Refable,
  type RefByPrimary,
  type RefByUnique,
  isRefByPrimary,
  isRefByUnique,
  refByPrimary,
} from 'domain-objects';
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';

/**
 * .what = resolves any ref to RefByPrimary for a given resource class
 * .why = enables converting generic Ref to specific RefByPrimary without manual checks
 *
 * .note
 *   - dao.dobj carries the resource class (no need to pass separately)
 *   - only requires dao.get.one.byUnique via context (minimal dependency)
 *   - if already RefByPrimary, returns as-is without db call
 */
export const getRefByPrimary = async <
  TResource extends DomainEntity<any>,
  TResourceClass extends Refable<any, any, any>,
>(
  input: {
    ref: Ref<TResourceClass>;
  },
  context: {
    dao: {
      dobj: TResourceClass;
      get: {
        one: {
          byUnique: (ref: RefByUnique<TResourceClass>) => Promise<TResource | null>;
        };
      };
    };
  },
): Promise<RefByPrimary<TResourceClass>> => {
  // if already given a refByPrimary, use it directly
  const isAlreadyByPrimary = isRefByPrimary({ of: context.dao.dobj })(
    input.ref,
  );
  if (isAlreadyByPrimary) return input.ref;

  // if given refByUnique, get the resource and extract primary key
  const isByUnique = isRefByUnique({ of: context.dao.dobj })(input.ref);
  if (isByUnique) {
    const found = await context.dao.get.one.byUnique(input.ref);
    if (!found)
      BadRequestError.throw(
        'cannot resolve refByPrimary: entity not found via refByUnique',
        { ref: input.ref, resourceClass: context.dao.dobj.name },
      );
    return refByPrimary({ of: context.dao.dobj })(found);
  }

  // otherwise, unexpected input
  throw new UnexpectedCodePathError(
    'ref was neither refByUnique nor refByPrimary',
    { ref: input.ref },
  );
};
```

### getRefByUnique

```typescript
// src/domain.operations/ref/getRefByUnique.ts

import {
  type DomainEntity,
  type Ref,
  type Refable,
  type RefByPrimary,
  type RefByUnique,
  isRefByPrimary,
  isRefByUnique,
  refByUnique,
} from 'domain-objects';
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';

/**
 * .what = resolves any ref to RefByUnique for a given resource class
 * .why = enables converting generic Ref to specific RefByUnique without manual checks
 *
 * .note
 *   - dao.dobj carries the resource class (no need to pass separately)
 *   - only requires dao.get.one.byPrimary via context (minimal dependency)
 *   - if already RefByUnique, returns as-is without db call
 */
export const getRefByUnique = async <
  TResource extends DomainEntity<any>,
  TResourceClass extends Refable<any, any, any>,
>(
  input: {
    ref: Ref<TResourceClass>;
  },
  context: {
    dao: {
      dobj: TResourceClass;
      get: {
        one: {
          byPrimary: (ref: RefByPrimary<TResourceClass>) => Promise<TResource | null>;
        };
      };
    };
  },
): Promise<RefByUnique<TResourceClass>> => {
  // if already given a refByUnique, use it directly
  const isAlreadyByUnique = isRefByUnique({ of: context.dao.dobj })(
    input.ref,
  );
  if (isAlreadyByUnique) return input.ref;

  // if given refByPrimary, get the resource and extract unique key
  const isByPrimary = isRefByPrimary({ of: context.dao.dobj })(input.ref);
  if (isByPrimary) {
    const found = await context.dao.get.one.byPrimary(input.ref);
    if (!found)
      BadRequestError.throw(
        'cannot resolve refByUnique: entity not found via refByPrimary',
        { ref: input.ref, resourceClass: context.dao.dobj.name },
      );
    return refByUnique({ of: context.dao.dobj })(found);
  }

  // otherwise, unexpected input
  throw new UnexpectedCodePathError(
    'ref was neither refByUnique nor refByPrimary',
    { ref: input.ref },
  );
};
```

## SDK Exports

update the sdk exports to include the new utilities:

```typescript
// src/contract/sdk/index.ts

// domain objects
export type { ContextDeclastruct } from '../../domain.objects/ContextDeclastruct';
export {
  DeclastructChange,
  DeclastructChangeAction,
} from '../../domain.objects/DeclastructChange';
export { DeclastructDao } from '../../domain.objects/DeclastructDao';
export { DeclastructPlan } from '../../domain.objects/DeclastructPlan';
export { DeclastructProvider } from '../../domain.objects/DeclastructProvider';
export type { IsoTimestamp } from '../../domain.objects/IsoTimestamp';

// ref utilities
export { getRefByPrimary } from '../../domain.operations/ref/getRefByPrimary';
export { getRefByUnique } from '../../domain.operations/ref/getRefByUnique';
```

## Usage Example

```typescript
import {
  DeclastructDao,
  getRefByPrimary,
  getRefByUnique,
} from 'declastruct';
import { DomainEntity, Ref, RefByPrimary } from 'domain-objects';

// define a resource
interface MyResource {
  uuid?: string;
  externalId: string;
  name: string;
}
class MyResource extends DomainEntity<MyResource> implements MyResource {
  public static primary = ['uuid'] as const;
  public static unique = ['externalId'] as const;
}

// given a generic ref (could be by uuid OR by externalId)
const someRef: Ref<typeof MyResource> = { externalId: 'ext-123' };

// resolve to RefByPrimary when you specifically need the uuid
const refByPrimaryResolved: RefByPrimary<typeof MyResource> =
  await getRefByPrimary(
    { ref: someRef },
    {
      dao: {
        dobj: MyResource,
        get: {
          one: {
            byUnique: (ref) => myResourceDao.get.one.byUnique(ref, dbContext),
          },
        },
      },
    },
  );

// now refByPrimaryResolved = { uuid: 'abc-123' }
```

## Alternative: DAO Method Implementation

dao implementers can optionally implement the `get.ref` methods directly:

```typescript
const myResourceDao: DeclastructDao<MyResource, typeof MyResource, MyContext> = {
  dobj: MyResource,
  get: {
    one: {
      byUnique: async (input, context) => { ... },
      byPrimary: async (input, context) => { ... },
      byRef: async (input, context) => { ... },
    },
    ref: {
      byPrimary: async (ref, context) =>
        getRefByPrimary(
          { ref },
          { dao: { dobj: MyResource, get: { one: { byUnique: (r) => myResourceDao.get.one.byUnique(r, context) } } } },
        ),
      byUnique: async (ref, context) =>
        getRefByUnique(
          { ref },
          { dao: { dobj: MyResource, get: { one: { byPrimary: (r) => myResourceDao.get.one.byPrimary!(r, context) } } } },
        ),
    },
  },
  set: {
    findsert: async (input, context) => { ... },
  },
};
```

## Testing Strategy

### Unit Tests

```typescript
// src/domain.operations/ref/getRefByPrimary.test.ts

import { given, when, then } from 'test-fns';
import { DomainEntity } from 'domain-objects';
import { getError } from 'test-fns';
import { BadRequestError } from 'helpful-errors';

import { getRefByPrimary } from './getRefByPrimary';

describe('getRefByPrimary', () => {
  interface TestResource {
    uuid?: string;
    externalId: string;
    name: string;
  }
  class TestResource extends DomainEntity<TestResource> implements TestResource {
    public static primary = ['uuid'] as const;
    public static unique = ['externalId'] as const;
  }

  given('a ref that is already RefByPrimary', () => {
    const ref = { uuid: 'abc-123' };

    when('getRefByPrimary is called', () => {
      then('it returns the ref as-is without db call', async () => {
        const mockByUnique = jest.fn();

        const result = await getRefByPrimary(
          { ref },
          {
            dao: {
              dobj: TestResource,
              get: { one: { byUnique: mockByUnique } },
            },
          },
        );

        expect(result).toEqual({ uuid: 'abc-123' });
        expect(mockByUnique).not.toHaveBeenCalled();
      });
    });
  });

  given('a ref that is RefByUnique', () => {
    const ref = { externalId: 'ext-456' };

    when('resource exists', () => {
      then('it returns the primary key from fetched resource', async () => {
        const mockByUnique = jest.fn().mockResolvedValue({
          uuid: 'resolved-uuid',
          externalId: 'ext-456',
          name: 'test',
        });

        const result = await getRefByPrimary(
          { ref },
          {
            dao: {
              dobj: TestResource,
              get: { one: { byUnique: mockByUnique } },
            },
          },
        );

        expect(result).toEqual({ uuid: 'resolved-uuid' });
        expect(mockByUnique).toHaveBeenCalledWith(ref);
      });
    });

    when('resource does not exist', () => {
      then('it throws BadRequestError', async () => {
        const mockByUnique = jest.fn().mockResolvedValue(null);

        const error = await getError(
          getRefByPrimary(
            { ref },
            {
              dao: {
                dobj: TestResource,
                get: { one: { byUnique: mockByUnique } },
              },
            },
          ),
        );

        expect(error).toBeInstanceOf(BadRequestError);
        expect(error.message).toContain('entity not found via refByUnique');
      });
    });
  });
});
```

### Type Tests

use `@ts-expect-error` to verify output types flow correctly at compile time:

```typescript
// src/domain.operations/ref/getRefByPrimary.test.ts (continued)

describe('getRefByPrimary type safety', () => {
  interface TestResource {
    uuid?: string;
    externalId: string;
    name: string;
  }
  class TestResource extends DomainEntity<TestResource> implements TestResource {
    public static primary = ['uuid'] as const;
    public static unique = ['externalId'] as const;
  }

  it('should return RefByPrimary type with uuid, not externalId', async () => {
    const mockByUnique = jest.fn().mockResolvedValue({
      uuid: 'test-uuid',
      externalId: 'ext-123',
      name: 'test',
    });

    const result = await getRefByPrimary(
      { ref: { externalId: 'ext-123' } },
      {
        dao: {
          dobj: TestResource,
          get: { one: { byUnique: mockByUnique } },
        },
      },
    );

    // result should be RefByPrimary<typeof TestResource> = { uuid: string }
    const uuid: string = result.uuid;
    expect(uuid).toBeDefined();

    // @ts-expect-error - externalId should NOT be on RefByPrimary
    const shouldFail = result.externalId;
    expect(shouldFail).toBeUndefined();
  });

  it('should accept a dao that implements get.one.byUnique for the resource', async () => {
    const dao: DeclastructDao<TestResource, typeof TestResource> = {
      dobj: TestResource,
      get: {
        one: {
          byUnique: async () => null,
          byRef: async () => null,
        },
      },
      set: {
        findsert: async (input) => input as any,
      },
    };

    // dao should fit the context shape
    await getRefByPrimary(
      { ref: { externalId: 'ext-123' } },
      { dao },
    ).catch(() => {});
  });
});
```

```typescript
// src/domain.operations/ref/getRefByUnique.test.ts (type tests)

describe('getRefByUnique type safety', () => {
  interface TestResource {
    uuid?: string;
    externalId: string;
    name: string;
  }
  class TestResource extends DomainEntity<TestResource> implements TestResource {
    public static primary = ['uuid'] as const;
    public static unique = ['externalId'] as const;
  }

  it('should return RefByUnique type with externalId, not uuid', async () => {
    const mockByPrimary = jest.fn().mockResolvedValue({
      uuid: 'test-uuid',
      externalId: 'ext-123',
      name: 'test',
    });

    const result = await getRefByUnique(
      { ref: { uuid: 'test-uuid' } },
      {
        dao: {
          dobj: TestResource,
          get: { one: { byPrimary: mockByPrimary } },
        },
      },
    );

    // result should be RefByUnique<typeof TestResource> = { externalId: string }
    const externalId: string = result.externalId;
    expect(externalId).toBeDefined();

    // @ts-expect-error - uuid should NOT be on RefByUnique
    const shouldFail = result.uuid;
    expect(shouldFail).toBeUndefined();
  });

  it('should accept a dao that implements get.one.byPrimary for the resource', async () => {
    const dao: DeclastructDao<TestResource, typeof TestResource> = {
      dobj: TestResource,
      get: {
        one: {
          byUnique: async () => null,
          byPrimary: async () => null,
          byRef: async () => null,
        },
      },
      set: {
        findsert: async (input) => input as any,
      },
    };

    // dao should fit the context shape
    await getRefByUnique(
      { ref: { uuid: 'test-uuid' } },
      { dao },
    ).catch(() => {});
  });
});
```

### DeclastructDao Interface Type Tests

```typescript
// src/domain.objects/DeclastructDao.test.ts

import { DomainEntity } from 'domain-objects';
import type { DeclastructDao } from './DeclastructDao';

describe('DeclastructDao type safety', () => {
  interface DemoResource {
    uuid?: string;
    externalId: string;
    name: string;
  }
  class DemoResource extends DomainEntity<DemoResource> implements DemoResource {
    public static primary = ['uuid'] as const;
    public static unique = ['externalId'] as const;
  }

  it('should require dobj attribute', () => {
    // @ts-expect-error - missing dobj
    const badDao: DeclastructDao<DemoResource, typeof DemoResource> = {
      get: {
        one: {
          byUnique: async () => null,
          byRef: async () => null,
        },
      },
      set: {
        findsert: async (input) => input as any,
      },
    };
    expect(badDao).toBeDefined();
  });

  it('should require get.one namespace', () => {
    // @ts-expect-error - using old flat structure
    const badDao: DeclastructDao<DemoResource, typeof DemoResource> = {
      dobj: DemoResource,
      get: {
        byUnique: async () => null,
        byRef: async () => null,
      },
      set: {
        findsert: async (input) => input as any,
      },
    };
    expect(badDao).toBeDefined();
  });

  it('should implement the new interface structure', () => {
    const dao: DeclastructDao<DemoResource, typeof DemoResource> = {
      dobj: DemoResource,
      get: {
        one: {
          byUnique: async () => null,
          byPrimary: async () => null,
          byRef: async () => null,
        },
      },
      set: {
        findsert: async (input) => input as any,
      },
    };

    expect(dao.dobj).toBe(DemoResource);
    expect(dao.get.one.byUnique).toBeDefined();
    expect(dao.get.one.byRef).toBeDefined();
    expect(dao.set.findsert).toBeDefined();
  });
});
```

## Implementation Phases

### Phase 1: Interface Breaking Change
1. update `DeclastructDao` interface:
   - add `dobj: TResourceClass` attribute
   - restructure `get` from flat to `get.one` + `get.ref`
   - add `.what` and `.why` comments to all operations
2. update all existing usages in the codebase:
   - `dao.get.byUnique` → `dao.get.one.byUnique`
   - `dao.get.byPrimary` → `dao.get.one.byPrimary`
   - `dao.get.byRef` → `dao.get.one.byRef`
   - add `dobj` to all dao instantiations
3. update `DeclastructDao.test.ts` to verify new interface structure
4. bump major version (breaking change)

### Phase 2: Core Utilities
1. implement `getRefByPrimary` in `src/domain.operations/ref/getRefByPrimary.ts`
2. implement `getRefByUnique` in `src/domain.operations/ref/getRefByUnique.ts`
3. add unit tests for both utilities
4. update sdk exports to include new utilities

### Phase 3: Documentation
1. update readme/docs with usage examples
2. add jsdoc comments with examples
3. document breaking change in changelog

## Success Criteria

1. **type safety**: full typescript coverage, no `any` in public api
2. **ergonomics**: simple one-liner to resolve refs
3. **efficiency**: no db call when ref is already the desired type
4. **fail-fast**: clear errors when resource not found
5. **composability**: works with any `DeclastructDao` implementation
6. **explicit**: `fn | null` type forces implementers to consciously decide on primary key support

## Non-Goals

- automatic memoization/caching of ref lookups (leave to dao implementers)
- batch ref resolution (can be added later if needed)
- ref validation utilities (separate concern)
