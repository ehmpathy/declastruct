vision =

each `declastruct-*` repo will declare

1. a provider, which specifies all of the `dao`s that can
   1. - get({ by: { unique, primary } })
   2. - set({ findsert, upsert })
   for each resource

note, we require
- findsert
- upsert
semantics in order to enforce the requirement of idempotency


note, we require
- get.by.unique
- get.by.primary
semantics in order to enforce the requirement of idempotency as well


each provider will implement these dao's based on explicitly declared
- `domain-objects`
  - where the DomainEntities and DomainLiterals will specifiy their
    - .primary
    - and
    - .unique
    - keys

not all resources will have .primary keys
but .unique keys are required in order to support idempotency


---

we also need to support that the `DeclastructDao` will specify what capacities are supported

e.g.,

```ts
interface DeclastructDao<TResource extends DomainEntity, TContext> {
  get: {
    byUnique: (input: RefByUnique<typeof T>, context: TContext) => T | null, // required, otherwise idempotency wont be supported
    byPrimary?: (input: RefByPrimary<typeof T>, context: TContext) => T | null, // optional, not all resources have primary keys
    byRef: (input: Ref<typeof T>, context: TContext) => T | null, // required, will support whatever references are supported
  },
  set: {
    findsert: (input: TResource, context: TContext) => HasMetadata<TResource>, // required, always must be able to atleast create a new one
    upsert?: (input: TResource, context: TContext) => HasMetadata<TResource>, // optional, we may not always support updates
    delete?: (input: TResource, context: TContext) => Promise<void>, // optional, we may not always support deletes
  }
}
```


---

we want to make it easy for

1. anyone to create a `declastruct` compatible provider
   1. declare resources
   2. declare dao per resource
   3. declare provider which bundles the below

```ts
interface DeclastructProvider<
  TDeclastructDaos extends Resource<DomainEntityName, DeclastructDao>,
  TContext,
> {
  daos: TDeclastructDaos,
  context: TContext,
  hooks: { beforeAll: () => Promise<void>, afterAll: () => Promise<void> }
}
```


----

that way, when someone tries to use providers and resources

as, for example,

```ts
import { getDeclastructAwsProvider, DeclaredAwsS3Bucket } from 'declastruct-aws';

// declare the providers that support your resources
export const getProviders = async () => [
    await getDeclastructAwsProvider({
      profile: process.env.AWS_PROFILE,
    })
  ]

// declare the resources in the states you want them
export const getResources = async () => {
  const bucket = DeclaredAwsS3Bucket.as({
    name: 'your-s3-bucket',
  });
  // declare other resources you wish to have

  return [
    bucket,
    // ... all the resources you wish for will go here
  ],
}
```


the `getDeclastructAwsProvider` would instantiate a `DeclastructProvider` with all the daos, context, and hooks instantiated

then, when

`npx declastruct plan --wish resources.ts` is called against that file

declastruct will
1. instantiate the providers
2. look at each of the resources
3. find the dao for each resource
4. `getByUnique` against each resource, to fetch it's remote state
5. declare the plan of the `ChangeProposal[]` required to get each resource into the declared wish state


e.g.,

```ts
import { DomainLiteral, DomainEntity } from 'domain-objects';

/**
 * an action that can be proposed
 */
export enum DeclastructChangeProposalAction {
  /**
   * keep it as is
   */
  KEEP = 'KEEP',

  /**
   * create a new resource
   */
  CREATE = 'CREATE',

  /**
   * update an existing resource
   */
  UPDATE = 'UPDATE',

  /**
   * destroy an existing resource
   */
  DESTROY = 'DESTROY',

  /**
   * replace an existing resource
   *
   * note
   * - this is a `delete` followed by a `create`
   */
  REPLACE = 'REPLACE',
}

/**
 * a change that declastruct has proposed in order to update the remote state to reflect the declared state
 */
export interface DeclastructChangeProposal<TResource extends DomainEntity> {
  /**
   * the name of the class of resource this proposal is for
   */
  forResourceClassName: string;

  /**
   * the scannable identity string of the resource this proposal is for
   */
  forScannableIdentifier: string;

  /**
   * the remote-state the resource is currently in, from which we will be changing it
   */
  fromRemoteState: R | null;

  /**
   * the desired-state the resource should be in, to which we will be changing it
   */
  toDesiredState: R | null;

  /**
   * the action we plan to execute in order to fulfil this proposed change
   */
  action: DeclastructChangeProposalAction;

  /**
   * the displayable difference made by the change
   */
  difference: string | null;
}

export class DeclastructChangeProposal<R extends DomainEntity>
  extends DomainLiteral<DeclastructChangeProposal<R>>
  implements DeclastructChangeProposal<R> {}
```


----

then, when someone runs


```sh
npx declastruct apply --plan provision/.temp/plan.json
```

it will
1. plan again
2. verify that the current plan matches the input plan; failfast if not, to say that the plan is invalid
3. apply the proposed changes





=-----


note, we dont want to create any `DeclaredResource` type

we want to leverage `DomainEntity` for declared resources, from `domain-objects`, directly. no extra middle-type
