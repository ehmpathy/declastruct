# Phase 5 Execution: Core Operations

## Executive Summary

Phase 5 called for implementing the two main declastruct workflows:
- `planChanges` - Generates a plan of changes required to achieve desired state
- `applyChanges` - Executes infrastructure changes in a controlled manner

Plus supporting operations:
- `assertPlanStillValid` - Validates plans haven't become stale
- Helper functions for hashing, timestamps, and resource extraction

**Status: COMPLETE** ✅

---

## Phase 5 Requirements

From roadmap `.behavior/v2025_11_21.contract/4.1.roadmap.v1.i1.md`:

### 5.1 planChanges

**Dependencies:** 1.5 (DeclastructProvider), 1.6 (DeclastructPlan), 3.1 (ContextDeclastruct), 4.1 (getDaoByResource), 4.2 (computeChange)

**Tasks:**
- [x] Create `src/domain.operations/plan/changes.ts`
- [x] Extract bottleneck from context
- [x] Map over resources with bottleneck scheduling
- [x] Fetch remote state via `dao.get.byUnique`
- [x] Compute change for each resource
- [x] Build and return plan with hash, timestamp, wish URI, and changes

**Acceptance Criteria:**
- [x] Accepts resources, providers, and wishFilePath
- [x] Uses bottleneck to control concurrency
- [x] Returns plan with all changes
- [x] Plan includes wish.uri
- [x] Idempotent (calling multiple times with same input produces same plan)

### 5.2 assertPlanStillValid

**Dependencies:** 1.6 (DeclastructPlan)

**Tasks:**
- [x] Create `src/domain.operations/plan/validate.ts`
- [x] Compare original plan hash with current plan hash
- [x] Throw `BadRequestError` if hashes differ

**Acceptance Criteria:**
- [x] Passes when hashes match
- [x] Throws with helpful context when hashes differ

### 5.3 applyChanges

**Dependencies:** 5.1 (planChanges), 5.2 (assertPlanStillValid), 4.3 (applyChange)

**Tasks:**
- [x] Create `src/domain.operations/apply/changes.ts`
- [x] Extract bottleneck from context
- [x] Re-plan to validate plan is still valid
- [x] Call `assertPlanStillValid`
- [x] Iterate through changes sequentially
- [x] Skip KEEP actions
- [x] Apply each change and collect results
- [x] Return applied changes

**Acceptance Criteria:**
- [x] Re-plans before applying
- [x] Validates plan hasn't changed
- [x] Skips KEEP actions
- [x] Applies changes sequentially (not parallel)
- [x] Returns list of applied changes
- [x] Idempotent (safe to rerun)

---

## Implementation

### File: `src/domain.operations/plan/helpers.ts`

**Purpose:** Utility functions for plan operations

**Functions implemented:**

1. **`asIsoTimestamp(date: Date): IsoTimestamp`**
   - Converts Date to ISO 8601 timestamp string
   - Ensures consistent timestamp format

2. **`hashChanges(changes: DeclastructChange[]): string`**
   - Computes deterministic SHA-256 hash of changes
   - Enables plan comparison and staleness detection
   - Uses JSON serialization for consistency

3. **`extractResourcesFromPlan(plan: DeclastructPlan): DomainEntity<any>[]`**
   - Extracts desired resources from plan's changes
   - Filters out null resources (DESTROY-only changes)
   - Needed for replanning during applyChanges

### File: `src/domain.operations/plan/changes.ts`

**Purpose:** Main planning workflow - generates infrastructure change plan

**Key features:**
- Extracts appropriate bottleneck (onPlan or single)
- Processes resources in parallel with concurrency control
- Fetches remote state for each resource
- Computes required changes
- Returns plan with hash, timestamp, and wish URI

**Implementation pattern:**
```typescript
const bottleneck = 'onPlan' in context.bottleneck
  ? context.bottleneck.onPlan
  : context.bottleneck;

const changes = await Promise.all(
  input.resources.map((resource) =>
    bottleneck.schedule(async () => {
      const dao = getDaoByResource({ resource, providers: input.providers });
      const remoteState = await dao.get.byUnique(resource, context);
      return computeChange({ desired: resource, remote: remoteState });
    }),
  ),
);

return new DeclastructPlan({
  hash: hashChanges(changes),
  createdAt: asIsoTimestamp(new Date()),
  wish: { uri: input.wishFilePath },
  changes,
});
```

### File: `src/domain.operations/plan/validate.ts`

**Purpose:** Validates that plans haven't become stale before applying

**Key features:**
- Compares original plan hash with current plan hash
- Throws `BadRequestError` with helpful context if different
- Prevents applying outdated changes

**Implementation pattern:**
```typescript
if (originalPlan.hash !== currentPlan.hash) {
  throw new BadRequestError('plan is stale', {
    originalHash: originalPlan.hash,
    currentHash: currentPlan.hash,
    message: 'The infrastructure state has changed since this plan was created...',
  });
}
```

### File: `src/domain.operations/apply/changes.ts`

**Purpose:** Main apply workflow - executes infrastructure changes

**Key features:**
- Extracts appropriate bottleneck (onApply or single)
- Re-plans to validate current state
- Validates plan hasn't become stale
- Applies changes sequentially
- Skips KEEP actions
- Returns list of applied changes

**Implementation pattern:**
```typescript
const currentPlan = await planChanges({
  resources: extractResourcesFromPlan(input.plan),
  providers: input.providers,
  wishFilePath: input.plan.wish.uri,
}, context);

assertPlanStillValid({
  originalPlan: input.plan,
  currentPlan,
});

const appliedChanges: DeclastructChange[] = [];

for (const change of input.plan.changes) {
  if (change.action === DeclastructChangeAction.KEEP) continue;

  const applied = await applyChange({
    change,
    providers: input.providers,
    context,
  });

  appliedChanges.push(applied);
}

return { appliedChanges };
```

---

## Dependencies

No new dependencies added - all functionality uses existing packages:
- `crypto` (Node.js built-in) for SHA-256 hashing
- `domain-objects` for DomainEntity types
- `helpful-errors` for BadRequestError
- `simple-log-methods` for ContextLogTrail

---

## Verification

### TypeScript Compilation

```
✅ tsc -p ./tsconfig.build.json --noEmit
```

### Build

```
✅ npm run build
```

All compilation successful, dist/ directory created.

---

## SDK Exports

Updated `src/contract/sdk/index.ts` to include all Phase 5 exports:

```typescript
// domain operations - plan
export { getDaoByResource } from '../../domain.operations/plan/getDaoByResource';
export { computeChange } from '../../domain.operations/plan/computeChange';
export { planChanges } from '../../domain.operations/plan/changes';
export { assertPlanStillValid } from '../../domain.operations/plan/validate';
export {
  asIsoTimestamp,
  hashChanges,
  extractResourcesFromPlan,
} from '../../domain.operations/plan/helpers';

// domain operations - apply
export { applyChange } from '../../domain.operations/apply/applyChange';
export { applyChanges } from '../../domain.operations/apply/changes';
```

---

## Progress Tracker

### 5.1 planChanges
- [x] Created `src/domain.operations/plan/changes.ts`
- [x] Extracted bottleneck from context (supports both single and split)
- [x] Mapped over resources with bottleneck scheduling
- [x] Fetched remote state via `dao.get.byUnique`
- [x] Computed change for each resource
- [x] Built and returned plan with hash, timestamp, wish URI, and changes
- [x] Implemented idempotent behavior (same inputs → same hash)

### 5.2 assertPlanStillValid
- [x] Created `src/domain.operations/plan/validate.ts`
- [x] Compared original and current plan hashes
- [x] Threw BadRequestError with helpful context when hashes differ
- [x] Provided clear error message for users

### 5.3 applyChanges
- [x] Created `src/domain.operations/apply/changes.ts`
- [x] Extracted bottleneck from context (supports both single and split)
- [x] Re-planned to validate current state
- [x] Called assertPlanStillValid to catch drift
- [x] Iterated through changes sequentially
- [x] Skipped KEEP actions
- [x] Applied each change and collected results
- [x] Returned applied changes
- [x] Implemented idempotent behavior (safe to rerun)

### Helper Functions
- [x] Created `src/domain.operations/plan/helpers.ts`
- [x] Implemented `asIsoTimestamp` for consistent timestamps
- [x] Implemented `hashChanges` for plan comparison
- [x] Implemented `extractResourcesFromPlan` for replanning

---

## Mechanic Patterns Followed

✅ **Immutability** - All variables use `const`, no `let` or `var`
✅ **Fail-fast** - Early validation with assertPlanStillValid
✅ **Arrow functions** - All functions declared with arrow syntax
✅ **Comment discipline** - All functions have `.what`, `.why`, `.note` headers
✅ **Domain-driven** - Uses DomainEntity and DomainPlan types
✅ **Error handling** - Uses BadRequestError from `helpful-errors`
✅ **Idempotency** - Both planChanges and applyChanges are idempotent
✅ **Concurrency control** - Uses bottleneck for controlled parallelism

---

## Key Design Decisions

### 1. SHA-256 for Hashing
Used Node.js built-in `crypto.createHash` with SHA-256 for deterministic plan hashing. This ensures:
- Consistent hashes across runs
- Detection of any change in plan content
- No additional dependencies

### 2. Sequential Application
Changes are applied sequentially (not in parallel) to:
- Ensure predictable execution order
- Avoid race conditions between dependent resources
- Simplify error handling and rollback scenarios

### 3. Plan Validation
Re-planning before applying ensures:
- Infrastructure hasn't drifted since plan creation
- Users are warned if state has changed
- Safe execution with up-to-date information

### 4. Bottleneck Flexibility
Supports both single bottleneck and split (onPlan/onApply) configurations:
- Single: Same concurrency limits for planning and applying
- Split: Different limits (e.g., higher for planning, lower for applying)

---

## Conclusion

**Phase 5: COMPLETE** ✅

The core declastruct workflows are now implemented:
- ✅ `planChanges` - Generates change plans with concurrency control
- ✅ `applyChanges` - Executes changes with validation
- ✅ `assertPlanStillValid` - Prevents stale plan application
- ✅ Helper functions for hashing, timestamps, and resource extraction

These operations provide the complete infrastructure-as-code workflow:
1. Define desired state (resources)
2. Plan changes (planChanges)
3. Review plan
4. Apply changes (applyChanges)

**Build status:** ✅ Successful compilation
**SDK exports:** ✅ All operations exported

**Ready to proceed to Phase 6 (CLI Commands).**
