# Blueprint: Declastruct Implementation

## Overview

This blueprint outlines the implementation of `declastruct` - a declarative infrastructure-as-code tool that enables users to declare, plan, and apply changes to any resource constructs through a type-safe, idempotent, and observable system.

## Core Architecture

### Bounded Contexts

Following `arch:bounded-contexts`, the system will be organized into the following domains:

```
src/
â”œâ”€â”€ domain.objects/          # canonical domain declarations
â”‚   â”œâ”€â”€ DeclastructProvider.ts
â”‚   â”œâ”€â”€ DeclastructDao.ts
â”‚   â”œâ”€â”€ DeclastructChange.ts
â”‚   â””â”€â”€ DeclastructPlan.ts
â”‚
â”œâ”€â”€ domain.operations/       # business logic and orchestration
â”‚   â”œâ”€â”€ plan/
â”‚   â”‚   â”œâ”€â”€ changes.ts
â”‚   â”‚   â””â”€â”€ validate.ts
â”‚   â””â”€â”€ apply/
â”‚       â””â”€â”€ changes.ts
â”‚
â”œâ”€â”€ contract/               # public interfaces
â”‚   â”œâ”€â”€ commands/           # CLI entrypoints
â”‚   â”‚   â”œâ”€â”€ plan.ts
â”‚   â”‚   â””â”€â”€ apply.ts
â”‚   â””â”€â”€ sdk/                # public SDK exports
â”‚       â””â”€â”€ index.ts        # package exports
â”‚
â””â”€â”€ infra/                  # infrastructure adapters
    â”œâ”€â”€ cli/                # command-line interface
    â””â”€â”€ log/                # observability
```

### Directional Dependencies

Following `arch:directional-deps`:

- `contract/` â†’ can depend on `domain.operations/`, `domain.objects/`, `infra/`
- `domain.operations/` â†’ can depend on `domain.objects/`, `infra/`
- `domain.objects/` â†’ standalone, no upward dependencies
- `infra/` â†’ standalone, no dependencies (pure infrastructure adapters)

Note: `access/` layer is not needed in the core package - it will exist in provider packages (e.g., `declastruct-aws`) which implement the `DeclastructDao` and `DeclastructProvider` interfaces.

## Domain Model

### Core Domain Objects

Following `arch:domain-driven-design`, all business concepts will be modeled as proper domain objects using `domain-objects` library.

#### 1. DeclastructDao

```typescript
/**
 * .what = standardized data access interface for any resource type
 * .why = enforces idempotent semantics and consistent access patterns across all providers
 * .note = TResource extends DomainEntity, which provides .unique and .primary keys
 */
export interface DeclastructDao<TResource extends DomainEntity, TContext> {
  get: {
    /**
     * required - fetch by unique keys (enables idempotency)
     */
    byUnique: (input: RefByUnique<TResource>, context: TContext) => Promise<TResource | null>;

    /**
     * optional - fetch by primary keys (if resource supports them)
     */
    byPrimary?: (input: RefByPrimary<TResource>, context: TContext) => Promise<TResource | null>;

    /**
     * required - fetch by any supported reference type
     */
    byRef: (input: Ref<TResource>, context: TContext) => Promise<TResource | null>;
  };

  set: {
    /**
     * required - find or insert resource (idempotent create)
     */
    findsert: (input: TResource, context: TContext) => Promise<HasMetadata<TResource>>;

    /**
     * optional - create or update resource (idempotent upsert)
     */
    upsert?: (input: TResource, context: TContext) => Promise<HasMetadata<TResource>>;

    /**
     * optional - delete resource
     */
    delete?: (input: Ref<TResource>, context: TContext) => Promise<void>;
  };
}

export class DeclastructDao<TResource extends DomainEntity, TContext>
  extends DomainLiteral<DeclastructDao<TResource, TContext>>
  implements DeclastructDao<TResource, TContext> {}
```

#### 2. DeclastructProvider

```typescript
/**
 * .what = bundles all DAOs and lifecycle hooks for a specific infrastructure provider
 * .why = enables plug-and-play support for different infrastructure backends (AWS, GCP, Azure, etc)
 */
export interface DeclastructProvider<
  TDeclastructDaos extends Record<string, DeclastructDao<any, TContext>> = Record<string, DeclastructDao<any, any>>,
  TContext = any,
> {
  /**
   * unique name identifying this provider
   */
  name: string;

  /**
   * map of resource class names to their DAOs
   */
  daos: TDeclastructDaos;

  /**
   * provider-specific context (credentials, region, etc)
   */
  context: TContext;

  /**
   * lifecycle hooks for setup and teardown
   */
  hooks: {
    beforeAll: () => Promise<void>;
    afterAll: () => Promise<void>;
  };
}

export class DeclastructProvider<TDeclastructDaos, TContext>
  extends DomainLiteral<DeclastructProvider<TDeclastructDaos, TContext>>
  implements DeclastructProvider<TDeclastructDaos, TContext> {}
```

#### 3. DeclastructChange

```typescript
/**
 * .what = describes a single change required to align remote state with desired state
 * .why = enables observable, auditable infrastructure changes
 */
export enum DeclastructChangeAction {
  KEEP = 'KEEP',
  CREATE = 'CREATE',
  UPDATE = 'UPDATE',
  DESTROY = 'DESTROY',
  REPLACE = 'REPLACE',
}

export interface DeclastructChange<TResource extends DomainEntity = DomainEntity> {
  /**
   * .what = which resources this is for
   */
  forResource: {
    /**
     * class name of the resource being changed
     */
    class: string

    /**
     * scannable identifier of this specific resource
     */
    slug: string;
  }

  /**
   * action to execute
   */
  action: DeclastructChangeAction;

  /**
   * .what = the states of the resource
   */
  state: {
    /**
     * .what = the desired state of the resource
     *
     * .note =
     *   - null if the resource doesn't exist
     */
    desired: TResource | null;

    /**
     * .what = the remote state of the resource
     *
     * .note =
     *   - null if resource should be deleted
     */
    remote: TResource | null;

    /**
     * human-readable diff of changes
     */
    difference: string | null;
  }
}

export class DeclastructChange<TResource extends DomainEntity = DomainEntity>
  extends DomainLiteral<DeclastructChange<TResource>>
  implements DeclastructChange<TResource> {}
```

#### 4. DeclastructPlan

```typescript
/**
 * ISO 8601 timestamp string
 */
export type IsoTimestamp = string;

/**
 * .what = collection of all planned changes required to fulfill a wish
 * .why = enables review, version control, and validation of infrastructure changes
 */
export interface DeclastructPlan {
  /**
   * hash of the proposed changes (for validation on apply)
   */
  hash: string;

  /**
   * timestamp when plan was created
   */
  createdAt: IsoTimestamp;

  /**
   * reference to the wish file
   */
  wish: {
    /**
     * file path URI to the wish file containing resources and providers
     */
    uri: string;
  };

  /**
   * all proposed changes
   */
  changes: DeclastructChange[];
}

export class DeclastructPlan
  extends DomainEntity<DeclastructPlan>
  implements DeclastructPlan {
  public static unique = ['hash'];
}
```

## Domain Operations

### Context

```typescript
import { ContextLogTrail } from 'simple-log-methods';

/**
 * .what = standard context for all declastruct operations
 * .why = provides concurrency control and log trail
 */
export type ContextDeclastruct = {
  /**
   * concurrency control - either single bottleneck or separate for plan/apply
   */
  bottleneck: Bottleneck | { onPlan: Bottleneck; onApply: Bottleneck };
};
```

### 1. planChanges

```typescript
/**
 * .what = generates a plan of changes required to achieve desired state
 * .why = enables users to review infrastructure changes before applying them
 * .note = idempotent - calling multiple times produces the same plan
 */
export const planChanges = async (
  input: {
    resources: DomainEntity[];
    providers: DeclastructProvider[];
    wishFilePath: string;
  },
  context: ContextLogTrail & ContextDeclastruct,
): Promise<DeclastructPlan> => {
  // extract bottleneck for planning
  const bottleneck = 'onPlan' in context.bottleneck
    ? context.bottleneck.onPlan
    : context.bottleneck;

  // compute change for each resource in parallel
  const changes = await Promise.all(
    input.resources.map((resource) =>
      bottleneck.schedule(async () => {
        // find DAO for this resource
        const dao = getDaoByResource({ resource, providers: input.providers });

        // fetch current remote state
        const remoteState = await dao.get.byUnique(resource, context);

        // compute change
        return computeChange({ desired: resource, remote: remoteState });
      }),
    ),
  );

  // return plan
  return DeclastructPlan.build({
    hash: hashChanges(changes),
    createdAt: asIsoTimestamp(new Date()),
    wish: {
      uri: input.wishFilePath,
    },
    changes,
  });
};
```

### 2. applyChanges

```typescript
/**
 * .what = applies a validated plan to achieve desired state
 * .why = executes infrastructure changes in a controlled, observable manner
 * .note = idempotent - reapplying same plan is safe (guards check if already applied)
 */
export const applyChanges = async (
  input: {
    plan: DeclastructPlan;
    providers: DeclastructProvider[];
  },
  context: ContextLogTrail & ContextDeclastruct,
): Promise<{ appliedChanges: DeclastructChange[] }> => {
  // extract bottleneck for applying
  const bottleneck = 'onApply' in context.bottleneck
    ? context.bottleneck.onApply
    : context.bottleneck;

  // replan to ensure plan is still valid
  const currentPlan = await planChanges({
    resources: extractResourcesFromPlan(input.plan),
    providers: input.providers,
    wishFilePath: input.plan.wish.uri,
  }, context);

  // validate plan matches current state
  assertPlanStillValid({
    originalPlan: input.plan,
    currentPlan,
  });

  // apply each change in sequence
  const appliedChanges = [];

  for (const change of input.plan.changes) {
    // skip KEEP actions
    if (change.action === DeclastructChangeAction.KEEP) continue;

    // apply the change
    const applied = await applyChange({
      change,
      providers: input.providers,
    });

    appliedChanges.push(applied);
  }

  return { appliedChanges };
};
```

### 3. Supporting Operations

```typescript
/**
 * .what = gets the DAO for a given resource from available providers
 * .why = enables automatic routing of operations to the correct provider
 */
const getDaoByResource = ({
  resource,
  providers,
}: {
  resource: DomainEntity;
  providers: DeclastructProvider[];
}): DeclastructDao<DomainEntity, any> => {
  // get resource class name
  const resourceClassName = resource.constructor.name;

  // find all DAOs applicable to this resource
  const daosApplicable = providers
    .map((provider) => ({
      from: provider.name,
      dao: provider.daos[resourceClassName],
    }))
    .filter((match) => match.dao);

  // reject if multiple providers support same resource
  if (daosApplicable.length > 1) {
    throw new UnexpectedCodePathError('multiple providers support same resource', {
      resource: resourceClassName,
      providers: daosApplicable.map((m) => m.from),
    });
  }

  // reject if no DAO found
  const [dao] = daosApplicable;
  if (!dao) {
    throw new UnexpectedCodePathError('no DAO found for resource', {
      resourceClassName,
      availableProviders: providers.map((p) => ({
        name: p.name,
        supportedResources: Object.keys(p.daos),
      })),
    });
  }

  return dao;
};

/**
 * .what = computes a single change by comparing desired vs remote state
 * .why = determines the action needed to achieve desired state for one resource
 */
const computeChange = ({
  desired,
  remote,
}: {
  desired: DomainEntity;
  remote: DomainEntity | null;
}): DeclastructChange => {
  // determine action based on state comparison
  const action = (() => {
    // resource doesn't exist remotely
    if (!remote) return DeclastructChangeAction.CREATE;

    // resource exists but should be deleted
    if (!desired) return DeclastructChangeAction.DESTROY;

    // no changes needed
    if (resourcesAreEquivalent(remote, desired)) return DeclastructChangeAction.KEEP;

    // resource exists and needs updating
    return DeclastructChangeAction.UPDATE;
  })();

  // compute displayable difference
  const difference = action === DeclastructChangeAction.KEEP
    ? null
    : computeDiff({ from: remote, into: desired });

  // return change
  return DeclastructChange.build({
    forResource: {
      class: desired.constructor.name,
      slug: getResourceIdentifier(desired),
    },
    action,
    state: {
      desired,
      remote,
      difference,
    },
  });
};

/**
 * .what = applies a single change to infrastructure
 * .why = executes the actual infrastructure modification
 */
const applyChange = async ({
  change,
  providers,
}: {
  change: DeclastructChange;
  providers: DeclastructProvider[];
}): Promise<DeclastructChange> => {
  // find DAO for this resource
  const dao = getDaoByResource({
    resource: change.state.desired,
    providers,
  });

  // execute action based on change type
  switch (change.action) {
    case DeclastructChangeAction.KEEP:
      // no action needed
      return change;

    case DeclastructChangeAction.CREATE:
      // create new resource
      await dao.set.findsert(change.state.desired);
      return change;

    case DeclastructChangeAction.UPDATE:
      // update existing resource
      if (!dao.set.upsert) {
        throw new UnexpectedCodePathError('DAO does not support updates', {
          resourceClassName: change.forResource.class,
        });
      }
      await dao.set.upsert(change.state.desired);
      return change;

    case DeclastructChangeAction.DESTROY:
      // delete resource
      if (!dao.set.delete) {
        throw new UnexpectedCodePathError('DAO does not support deletes', {
          resourceClassName: change.forResource.class,
        });
      }
      await dao.set.delete(change.state.remote);
      return change;

    case DeclastructChangeAction.REPLACE:
      // delete then create
      if (!dao.set.delete) {
        throw new UnexpectedCodePathError('DAO does not support deletes', {
          resourceClassName: change.forResource.class,
        });
      }
      await dao.set.delete(change.state.remote);
      await dao.set.findsert(change.state.desired);
      return change;

    default:
      throw new UnexpectedCodePathError('unknown change action', {
        action: change.action,
      });
  }
};
```

## CLI Commands

### 1. plan command

```typescript
/**
 * .what = CLI entrypoint for generating infrastructure change plans
 * .why = exposes planning functionality to users
 */
export const executePlanCommand = async (
  input: {
    wishFilePath: string;
    planFilePath: string;
  },
  context: ContextLogTrail & ContextDeclastruct,
) => {
  // load wish file (resources + providers)
  const { getResources, getProviders } = await import(input.wishFilePath);

  // fetch resources and providers
  const [resources, providers] = await Promise.all([
    getResources(),
    getProviders(),
  ]);

  // initialize all providers
  await Promise.all(providers.map((p) => p.hooks.beforeAll()));

  // generate plan
  const plan = await planChanges({
    resources,
    providers,
    wishFilePath: input.wishFilePath,
  }, context);

  // cleanup all providers
  await Promise.all(providers.map((p) => p.hooks.afterAll()));

  // log each planned change
  for (const change of plan.changes) {
    const action = change.action === DeclastructChangeAction.KEEP
      ? 'â†“'
      : 'â—‹';
    const actionLabel = change.action;
    const resourceSlug = `resource:${change.forResource.class}:${change.forResource.slug}`;
    console.log(`${action} [${actionLabel}] ${resourceSlug}`);
  }

  // write plan to file
  await writeFile(
    input.planFilePath,
    JSON.stringify(plan, null, 2),
  );

  // log summary
  console.log()
  console.log(`ðŸŒŠ planned for ${plan.changes.length} resources`);
  console.log(`   into ${input.outputFilePath}`);
};
```

### 2. apply command

```typescript
/**
 * .what = CLI entrypoint for applying infrastructure change plans
 * .why = exposes apply functionality to users
 */
export const executeApplyCommand = async (
  input: {
    planFilePath: string;
  },
  context: ContextLogTrail & ContextDeclastruct,
) => {
  // grab wish file path from
  const planJson = await readFile(input.planFilePath, 'utf-8');
  const plan = DeclastructPlan.build(JSON.parse(planJson));

  // load wish file (resources + providers)
  const { getResources, getProviders } = await import(plan.wish.uri);

  // fetch resources and providers
  const [resources, providers] = await Promise.all([
    getResources(),
    getProviders(),
  ]);

  // initialize all providers
  await Promise.all(providers.map((p) => p.hooks.beforeAll()));

  // apply changes with real-time logging
  const appliedChanges: DeclastructChange[] = [];

  for (const change of plan.changes) {
    const resourceSlug = change.forResource.slug;

    try {
      // apply the change
      if (change.action !== DeclastructChangeAction.KEEP) {
        const applied = await applyChange({ change, providers });
        appliedChanges.push(applied);
        console.log(`âœ” [${change.action}] ${resourceSlug}`);
      } else {
        console.log(`â†“ [${change.action}] ${resourceSlug}`);
      }
    } catch (error) {
      console.log(`âœ– [${change.action}] ${resourceSlug}`);
      console.error(error)
      throw error;
    }
  }

  // cleanup all providers
  await Promise.all(providers.map((p) => p.hooks.afterAll()));

  // log summary
  console.log();
  console.log(`ðŸŒŠ applied ${appliedChanges.length} changes`);
};
```

## Type Safety & References

### Flexible Reference System

Following the vision, resources can be referenced via:
- **unique keys** (always supported, required for idempotency)
- **primary keys** (optional, if resource supports them)
- **any supported reference** (via `byRef`)

```typescript
/**
 * .what = extracts unique key reference from a resource
 * .why = enables idempotent lookups
 * .note = leverages DomainEntity.unique property
 */
export type RefByUnique<T extends DomainEntity> = Pick<
  T,
  T['unique'][number]
>;

/**
 * .what = extracts primary key reference from a resource
 * .why = enables efficient lookups when primary keys are available
 * .note = leverages DomainEntity.primary property
 */
export type RefByPrimary<T extends DomainEntity> = T['primary'] extends string[]
  ? Pick<T, T['primary'][number]>
  : never;

/**
 * .what = union of all supported reference types
 * .why = enables flexible resource resolution
 */
export type Ref<T extends DomainEntity> =
  | RefByUnique<T>
  | RefByPrimary<T>;
```

## Error Handling

Following `flow:fail-fast`, all operations use early returns and `HelpfulError` subclasses:

```typescript
// reject if wish file doesn't exist
if (!existsSync(input.wishFilePath)) {
  throw new BadRequestError('wish file not found', {
    wishFilePath: input.wishFilePath
  });
}

// halt if DAO not found for resource
if (!dao) {
  throw new UnexpectedCodePathError('no DAO found for resource', {
    resourceClassName: resource.constructor.name,
    availableProviders: providers.map(p => Object.keys(p.daos)),
  });
}

// reject if plan is stale
if (originalPlan.hash !== currentPlan.hash) {
  throw new BadRequestError('plan is stale; proposed changes have changed', {
    originalHash: originalPlan.hash,
    currentHash: currentPlan.hash,
  });
}
```

## Idempotency Guarantees

Following `proc:require-idempotency`:

### Planning
- Multiple `plan` calls with same input â†’ same output plan
- Plan generation fetches current state fresh each time (no cached state)

### Applying
- Apply re-plans before executing to validate plan is still valid
- Each change checks current state before executing:
  ```typescript
  // skip if resource already exists in desired state
  if (change.action === DeclastructChangeAction.CREATE) {
    const existing = await dao.get.byUnique(change.state.desired);
    if (existing && resourcesAreEquivalent(existing, change.state.desired)) {
      return change; // no-op, already applied
    }
  }
  ```

### DAO Operations
- `findsert`: find or insert - returns existing resource if found by unique keys, otherwise creates (idempotent)
- `upsert`: creates or updates (idempotent)
- All operations use unique keys for idempotent lookups

## Immutability

Following `vars:require-immutable`:

- All domain objects are immutable (via `domain-objects`)
- State changes use `.clone()` or object spread
- No mutation of input parameters
- Plans are snapshots, not live references

```typescript
// update proposal with new difference
const updated = proposal.clone({
  difference: computeDiff(proposal.fromRemoteState, proposal.toDesiredState),
});
```

## Code Style

Following `codestyle` tactics:

### Arrow Functions & Input-Context Pattern
```typescript
/**
 * .what = computes a change for a single resource
 * .why = determines what action is needed to achieve desired state
 */
export const computeChange = (
  input: {
    desired: DomainEntity;
    remote: DomainEntity | null;
  },
): DeclastructChange => {
  // determine action based on state comparison
  const action = determineChangeAction({ desired: input.desired, remote: input.remote });

  // compute displayable difference
  const difference = computeDiff({ from: input.remote, into: input.desired });

  // return change
  return DeclastructChange.build({
    forResource: {
      class: input.desired.constructor.name,
      slug: getResourceIdentifier(input.desired),
    },
    action,
    state: {
      desired: input.desired,
      remote: input.remote,
      difference,
    },
  });
};
```

### Code Paragraphs & Comments
```typescript
/**
 * .what = applies a single change to infrastructure
 * .why = executes the actual resource modification
 */
const applyChange = async (input, context) => {
  // find the DAO for this resource
  const dao = getDaoByResource({
    resource: input.change.toDesiredState,
    providers: input.providers,
  });

  // execute action based on change type
  switch (input.change.action) {
    case DeclastructChangeAction.CREATE:
      // create new resource
      return await dao.set.findsert(input.change.toDesiredState, context);

    case DeclastructChangeAction.UPDATE:
      // update existing resource
      if (!dao.set.upsert) {
        throw new UnexpectedCodePathError('DAO does not support updates', {
          resourceClassName: input.change.forResourceClassName,
        });
      }
      return await dao.set.upsert(input.change.toDesiredState, context);

    // ... other cases
  }
};
```

## Implementation Phases

### Phase 1: Core Framework
1. Implement domain objects
   - `DeclastructDao` interface
   - `DeclastructProvider` interface
   - `DeclastructChange` entity
   - `DeclastructPlan` entity

2. Implement reference type system
   - `RefByUnique<T>`
   - `RefByPrimary<T>`
   - `Ref<T>`
   - Helper utilities for reference resolution

3. Implement core operations
   - `getDaoByResource`
   - `computeChange`
   - `planChanges`

### Phase 2: Change Application
1. Implement apply operations
   - `assertPlanStillValid`
   - `applyChange`
   - `applyChanges`

2. Add error handling
   - `HelpfulError` subclasses
   - Validation guards
   - Rollback mechanisms

### Phase 3: CLI Interface
1. Implement commands
   - `plan` command
   - `apply` command

2. Add observability
   - Progress logging
   - Diff visualization
   - Plan summary output

### Phase 4: Provider Ecosystem
1. Document provider contract
   - Provider implementation guide
   - DAO implementation patterns
   - Testing utilities

2. Create example provider
   - In-memory provider (for testing)
   - Documentation with examples

## Testing Strategy

Following mechanic testing principles:

### Unit Tests
- Domain object construction and validation
- Reference type extraction
- Change proposal computation logic
- Plan validation

### Integration Tests
- Full plan â†’ apply cycle with in-memory provider
- Error handling scenarios
- Idempotency verification
- Concurrent execution safety

### Contract Tests
- Provider interface compliance
- DAO operation semantics
- Hook execution order

## Success Criteria

1. **Type Safety**: Full TypeScript coverage with no `any` types in public API
2. **Idempotency**: All operations can be safely retried
3. **Observability**: Clear logging of all infrastructure changes
4. **Extensibility**: Easy to add new providers and resource types
5. **No State Management**: Direct reads from source of truth (no terraform.tfstate equivalent)
6. **Domain Language**: Use domain objects, not raw JSON bags
7. **Directional Dependencies**: Strict layer boundaries enforced
8. **Immutability**: No mutation of shared state

## Non-Goals

- Dependency graph resolution (resources are independent)
- Parallelization of changes (execute sequentially for safety)
- State file management (stateless by design)
- Complex plan orchestration (keep it simple)
- Custom DSL (use TypeScript domain objects)

## Example Usage Flow

```typescript
// provision/resources.ts
import { getDeclastructAwsProvider, DeclaredAwsS3Bucket } from 'declastruct-aws';

export const getProviders = async () => [
  await getDeclastructAwsProvider({
    profile: process.env.AWS_PROFILE,
  }),
];

export const getResources = async () => {
  const bucket = DeclaredAwsS3Bucket.build({
    name: 'my-application-assets',
    region: 'us-east-1',
    versioning: { enabled: true },
  });

  return [bucket];
};
```

```sh
# generate plan
npx declastruct plan --wish provision/resources.ts --into provision/.temp/plan.json

# review plan
cat provision/.temp/plan.json

# apply changes
npx declastruct apply --plan provision/.temp/plan.json
```

## Conclusion

This blueprint provides a comprehensive roadmap for implementing `declastruct` following all `ehmpathy` architecture and code style principles. The design emphasizes:

- **Domain-driven design** with proper domain objects
- **Type safety** with flexible reference system
- **Idempotency** at all layers
- **Observability** through explicit planning
- **Simplicity** by avoiding unnecessary abstractions
- **Extensibility** via provider contract

The implementation will proceed phase by phase, ensuring each layer is solid before building the next.
