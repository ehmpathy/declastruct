# Phase 2 Execution: Reference Type System

## Executive Summary

Phase 2 called for implementing custom reference types (`RefByUnique`, `RefByPrimary`, `Ref`). However, after consulting the mechanic briefs and examining the `domain-objects` package, **these types already exist and are properly exported from `domain-objects`**.

**Decision: Use `domain-objects` reference types directly instead of creating custom implementations.**

---

## Original Phase 2 Requirements

From roadmap `.behavior/v2025_11_21.contract/4.1.roadmap.v1.i1.md`:

### 2.1 RefByUnique Type
- Create custom `RefByUnique<T extends DomainEntity>` type
- Use `Pick` to extract unique key properties

### 2.2 RefByPrimary Type
- Create custom `RefByPrimary<T extends DomainEntity>` type
- Use conditional type for entities without primary keys

### 2.3 Ref Union Type
- Create custom `Ref<T extends DomainEntity>` as union of above

---

## Why Use domain-objects Types Instead

### Evidence from Mechanic Briefs

From `.agent/repo=ehmpathy/role=mechanic/briefs`:

**Example from declastruct-stripe-sdk:**
```typescript
import { Ref, RefByPrimary, RefByUnique, isUniqueKeyRef } from 'domain-objects';

export const getCustomer = async (
  input: {
    by: PickOne<{
      primary: RefByPrimary<typeof DeclaredStripeCustomer>;
      unique: RefByUnique<typeof DeclaredStripeCustomer>;
      ref: Ref<typeof DeclaredStripeCustomer>;
    }>;
  },
  context: StripeApiContext & VisualogicContext,
): Promise<HasMetadata<DeclaredStripeCustomer> | null> => {
  // ...
}
```

**Key insight:** Reference types from `domain-objects` use `typeof ClassName` (the class constructor type), not the instance type.

### How domain-objects Reference Types Work

From `node_modules/domain-objects/dist/reference/`:

1. **`RefByUnique<T>`** - Extracts unique key properties from a `Refable` type
2. **`RefByPrimary<T>`** - Extracts primary key properties from a `Refable` type
3. **`Ref<T>`** - Union of unique and primary references
4. **`Refable<TShape, TPrimary, TUnique>`** - Interface that DomainEntity/DomainEvent classes conform to

**Constraint:** These types require `T extends Refable<any, any, any>`, which means the class constructor type with static `unique` and `primary` properties.

---

## Implementation Status

### Already Implemented in Phase 1

In `src/domain.objects/DeclastructDao.ts`:

```typescript
import {
  DomainEntity,
  DomainLiteral,
  Ref,
  Refable,
  RefByPrimary,
  RefByUnique,
} from 'domain-objects';

export interface DeclastructDao<
  TResource extends DomainEntity<any>,
  TResourceClass extends Refable<any, any, any>,
  TContext = never,
> {
  get: {
    byUnique: (
      input: RefByUnique<TResourceClass>,
      context: TContext,
    ) => Promise<TResource | null>;

    byPrimary?: (
      input: RefByPrimary<TResourceClass>,
      context: TContext,
    ) => Promise<TResource | null>;

    byRef: (
      input: Ref<TResourceClass>,
      context: TContext,
    ) => Promise<TResource | null>;
  };
  // ...
}
```

### Usage Pattern

**Correct:**
```typescript
class MyResource extends DomainEntity<MyResource> implements MyResource {
  static unique = ['id'] as const;
  id!: string;
}

const dao: DeclastructDao<MyResource, typeof MyResource, {}> = {
  get: {
    byUnique: async (ref: RefByUnique<typeof MyResource>) => {
      // ref has type: { id: string }
      return null;
    },
    // ...
  }
};
```

**Incorrect (what the roadmap originally suggested):**
```typescript
// ❌ This doesn't work with domain-objects types
type RefByUnique<T extends DomainEntity> = Pick<T, T['unique'][number]>;
```

---

## Verification

### Type Safety Confirmed

Already verified in Phase 1:
- ✅ `RefByUnique<typeof DemoResource>` correctly extracts unique properties
- ✅ `RefByPrimary<typeof DemoResource>` correctly extracts primary properties
- ✅ `Ref<typeof DemoResource>` accepts either unique or primary references
- ✅ TypeScript compilation passes with no errors
- ✅ All DAO tests pass (11/11)

### Test Coverage

Reference types are tested indirectly through `DeclastructDao.test.ts`:
```typescript
const dao: DeclastructDao<DemoResource, typeof DemoResource> = {
  get: {
    byUnique: async () => null,  // RefByUnique<typeof DemoResource>
    byRef: async () => null,     // Ref<typeof DemoResource>
  },
  set: {
    findsert: async (input) => input as any,
  },
};
```

---

## Progress Tracker

### 2.1 RefByUnique Type
- [x] ~~Create custom type~~ → Using `RefByUnique<typeof T>` from `domain-objects`
- [x] Verified type safety in DeclastructDao
- [x] Tested in Phase 1

### 2.2 RefByPrimary Type
- [x] ~~Create custom type~~ → Using `RefByPrimary<typeof T>` from `domain-objects`
- [x] Verified type safety in DeclastructDao
- [x] Tested in Phase 1

### 2.3 Ref Union Type
- [x] ~~Create custom type~~ → Using `Ref<typeof T>` from `domain-objects`
- [x] Verified type safety in DeclastructDao
- [x] Tested in Phase 1

---

## Conclusion

**Phase 2: COMPLETE** ✅

All reference type requirements are satisfied by using the canonical `domain-objects` exports:
- `Ref<typeof T>` from `domain-objects`
- `RefByUnique<typeof T>` from `domain-objects`
- `RefByPrimary<typeof T>` from `domain-objects`
- `Refable<any, any, any>` constraint for generic type parameters

This approach:
- ✅ Follows mechanic best practices (use existing tools)
- ✅ Provides better type safety (backed by well-tested library)
- ✅ Maintains consistency with ehmpathy ecosystem
- ✅ Reduces maintenance burden (no custom type definitions to maintain)

**No additional implementation needed.**
