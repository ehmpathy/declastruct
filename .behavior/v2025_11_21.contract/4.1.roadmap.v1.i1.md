# Roadmap: Declastruct Implementation

## Overview

This roadmap provides an ordered, dependency-aware checklist for implementing declastruct as specified in `3.3.blueprint.v1.i1.md`. Each task includes behavioral acceptance criteria and verification steps.

---

## Phase 1: Core Domain Objects

### 1.1 Implement IsoTimestamp Type

**Dependencies:** None

**Tasks:**
- [ ] Create `src/domain.objects/IsoTimestamp.ts`
- [ ] Export `IsoTimestamp` type as `string` with JSDoc

**Acceptance Criteria:**
- Type exported and importable
- Can be used to type ISO 8601 timestamp strings

**Verification:**
```typescript
import { IsoTimestamp } from './domain.objects/IsoTimestamp';
const timestamp: IsoTimestamp = '2025-01-15T10:30:00.000Z';
// Should compile without errors
```

---

### 1.2 Implement DeclastructChangeAction Enum

**Dependencies:** None

**Tasks:**
- [ ] Create `src/domain.objects/DeclastructChange.ts`
- [ ] Define `DeclastructChangeAction` enum with values: KEEP, CREATE, UPDATE, DESTROY, REPLACE

**Acceptance Criteria:**
- Enum exports all 5 action types
- Each action has correct string value

**Verification:**
```typescript
import { DeclastructChangeAction } from './domain.objects/DeclastructChange';
expect(DeclastructChangeAction.CREATE).toBe('CREATE');
expect(DeclastructChangeAction.KEEP).toBe('KEEP');
// Test all 5 values
```

---

### 1.3 Implement DeclastructChange Domain Object

**Dependencies:** 1.2

**Tasks:**
- [ ] Define `DeclastructChange<TResource>` interface in `src/domain.objects/DeclastructChange.ts`
- [ ] Include `forResource.class` and `forResource.slug`
- [ ] Include `action: DeclastructChangeAction`
- [ ] Include `state.desired`, `state.remote`, `state.difference`
- [ ] Extend `DomainLiteral<DeclastructChange<TResource>>`
- [ ] Set default type parameter to `DomainEntity`

**Acceptance Criteria:**
- Interface has all required properties with correct types
- Class extends `DomainLiteral` correctly
- Can build instances with `.build()`
- Type parameter defaults to `DomainEntity`

**Verification:**
```typescript
import { DeclastructChange, DeclastructChangeAction } from './domain.objects/DeclastructChange';
import { DomainEntity } from 'domain-objects';

class TestResource extends DomainEntity<TestResource> {
  static unique = ['id'];
  id!: string;
}

const change = DeclastructChange.build({
  forResource: { class: 'TestResource', slug: 'test-1' },
  action: DeclastructChangeAction.CREATE,
  state: {
    desired: TestResource.build({ id: 'test-1' }),
    remote: null,
    difference: null,
  },
});

expect(change.forResource.class).toBe('TestResource');
expect(change.action).toBe(DeclastructChangeAction.CREATE);
```

---

### 1.4 Implement DeclastructDao Interface

**Dependencies:** None

**Tasks:**
- [ ] Create `src/domain.objects/DeclastructDao.ts`
- [ ] Define `DeclastructDao<TResource, TContext>` interface
- [ ] Implement `get.byUnique`, `get.byPrimary`, `get.byRef` methods
- [ ] Implement `set.findsert`, `set.upsert`, `set.delete` methods
- [ ] Create class extending `DomainLiteral`

**Acceptance Criteria:**
- Interface has all required methods with correct signatures
- Optional methods marked with `?`
- Type parameters work correctly

**Verification:**
```typescript
import { DeclastructDao } from './domain.objects/DeclastructDao';

interface TestDao extends DeclastructDao<TestResource, {}> {}

// Should compile - verifies interface structure
const dao: TestDao = {
  get: {
    byUnique: async (input) => null,
    byRef: async (input) => null,
  },
  set: {
    findsert: async (input) => input as any,
  },
};
```

---

### 1.5 Implement DeclastructProvider Domain Object

**Dependencies:** 1.4

**Tasks:**
- [ ] Create `src/domain.objects/DeclastructProvider.ts`
- [ ] Define `DeclastructProvider<TDeclastructDaos, TContext>` interface
- [ ] Add `name: string` property
- [ ] Add `daos: TDeclastructDaos` property
- [ ] Add `context: TContext` property
- [ ] Add `hooks.beforeAll` and `hooks.afterAll`
- [ ] Set default type parameters
- [ ] Create class extending `DomainLiteral`

**Acceptance Criteria:**
- Interface has all required properties
- Default type parameters work
- Can build providers without explicit type args

**Verification:**
```typescript
import { DeclastructProvider } from './domain.objects/DeclastructProvider';

const provider = DeclastructProvider.build({
  name: 'test-provider',
  daos: {},
  context: {},
  hooks: {
    beforeAll: async () => {},
    afterAll: async () => {},
  },
});

expect(provider.name).toBe('test-provider');
```

---

### 1.6 Implement DeclastructPlan Domain Object

**Dependencies:** 1.1, 1.3

**Tasks:**
- [ ] Create `src/domain.objects/DeclastructPlan.ts`
- [ ] Define `DeclastructPlan` interface
- [ ] Add `hash: string` property
- [ ] Add `createdAt: IsoTimestamp` property
- [ ] Add `wish.uri: string` property
- [ ] Add `changes: DeclastructChange[]` property
- [ ] Extend `DomainEntity<DeclastructPlan>`
- [ ] Set `static unique = ['hash']`

**Acceptance Criteria:**
- Interface has all required properties
- Extends `DomainEntity` correctly
- Unique key is `hash`

**Verification:**
```typescript
import { DeclastructPlan } from './domain.objects/DeclastructPlan';

const plan = DeclastructPlan.build({
  hash: 'abc123',
  createdAt: '2025-01-15T10:30:00.000Z',
  wish: { uri: '/path/to/wish.ts' },
  changes: [],
});

expect(plan.hash).toBe('abc123');
expect(DeclastructPlan.unique).toEqual(['hash']);
```

---

## Phase 2: Reference Type System

### 2.1 Implement RefByUnique Type

**Dependencies:** None

**Tasks:**
- [ ] Create `src/domain.objects/references.ts`
- [ ] Define `RefByUnique<T extends DomainEntity>` type
- [ ] Use `Pick` to extract unique key properties

**Acceptance Criteria:**
- Type correctly extracts unique properties from DomainEntity

**Verification:**
```typescript
import { RefByUnique } from './domain.objects/references';

class TestEntity extends DomainEntity<TestEntity> {
  static unique = ['id', 'slug'];
  id!: string;
  slug!: string;
  name!: string;
}

const ref: RefByUnique<TestEntity> = { id: '123', slug: 'test' };
// Should compile

// @ts-expect-error - should not allow extra properties
const invalid: RefByUnique<TestEntity> = { id: '123', slug: 'test', name: 'foo' };
```

---

### 2.2 Implement RefByPrimary Type

**Dependencies:** None

**Tasks:**
- [ ] Add `RefByPrimary<T extends DomainEntity>` to `src/domain.objects/references.ts`
- [ ] Use conditional type to handle entities without primary keys

**Acceptance Criteria:**
- Type correctly extracts primary properties when available
- Returns `never` when no primary keys exist

**Verification:**
```typescript
import { RefByPrimary } from './domain.objects/references';

class EntityWithPrimary extends DomainEntity<EntityWithPrimary> {
  static primary = ['uuid'];
  uuid!: string;
}

const ref: RefByPrimary<EntityWithPrimary> = { uuid: 'abc-123' };
// Should compile
```

---

### 2.3 Implement Ref Union Type

**Dependencies:** 2.1, 2.2

**Tasks:**
- [ ] Add `Ref<T extends DomainEntity>` to `src/domain.objects/references.ts`
- [ ] Create union of `RefByUnique | RefByPrimary`

**Acceptance Criteria:**
- Type accepts either unique or primary reference

**Verification:**
```typescript
import { Ref } from './domain.objects/references';

const refByUnique: Ref<TestEntity> = { id: '123', slug: 'test' };
const refByPrimary: Ref<EntityWithPrimary> = { uuid: 'abc-123' };
// Both should compile
```

---

## Phase 3: Context Types

### 3.1 Implement ContextDeclastruct Type

**Dependencies:** None

**Tasks:**
- [ ] Create `src/domain.objects/ContextDeclastruct.ts`
- [ ] Define `ContextDeclastruct` type with `bottleneck` property
- [ ] Support single `Bottleneck` or `{ onPlan, onApply }`

**Acceptance Criteria:**
- Type accepts both bottleneck configurations
- Can be intersected with `ContextLogTrail`

**Verification:**
```typescript
import { ContextDeclastruct } from './domain.objects/ContextDeclastruct';
import Bottleneck from 'bottleneck';

const singleBottleneck: ContextDeclastruct = {
  bottleneck: new Bottleneck({ maxConcurrent: 5 }),
};

const splitBottleneck: ContextDeclastruct = {
  bottleneck: {
    onPlan: new Bottleneck({ maxConcurrent: 10 }),
    onApply: new Bottleneck({ maxConcurrent: 1 }),
  },
};
// Both should compile
```

---

## Phase 4: Supporting Operations

### 4.1 Implement getDaoByResource

**Dependencies:** 1.4, 1.5

**Tasks:**
- [ ] Create `src/domain.operations/utils/getDaoByResource.ts`
- [ ] Implement DAO lookup by resource class name
- [ ] Fail-fast if multiple providers support same resource
- [ ] Fail-fast if no provider supports resource
- [ ] Use immutable implementation (no `let`)

**Acceptance Criteria:**
- Returns correct DAO when exactly one provider matches
- Throws `UnexpectedCodePathError` with provider names when multiple match
- Throws `UnexpectedCodePathError` with available providers when none match
- No mutation (uses `const` only)

**Verification:**
```typescript
import { getDaoByResource } from './domain.operations/utils/getDaoByResource';

// Test: single matching provider
const dao = getDaoByResource({
  resource: TestResource.build({ id: 'test' }),
  providers: [provider1],
});
expect(dao).toBe(provider1.daos['TestResource']);

// Test: multiple providers
expect(() => getDaoByResource({
  resource: TestResource.build({ id: 'test' }),
  providers: [provider1, provider2],
})).toThrow('multiple providers support same resource');

// Test: no providers
expect(() => getDaoByResource({
  resource: TestResource.build({ id: 'test' }),
  providers: [],
})).toThrow('no DAO found for resource');
```

---

### 4.2 Implement computeChange

**Dependencies:** 1.3

**Tasks:**
- [ ] Create `src/domain.operations/utils/computeChange.ts`
- [ ] Implement action determination logic using IIFE (no `let`)
- [ ] Compute diff when action is not KEEP
- [ ] Build and return `DeclastructChange`

**Acceptance Criteria:**
- Returns CREATE when remote is null
- Returns DESTROY when desired is null
- Returns KEEP when resources are equivalent
- Returns UPDATE when resources differ
- No mutation (uses IIFE for action computation)

**Verification:**
```typescript
import { computeChange } from './domain.operations/utils/computeChange';

// Test: CREATE
const createChange = computeChange({
  desired: TestResource.build({ id: 'new' }),
  remote: null,
});
expect(createChange.action).toBe(DeclastructChangeAction.CREATE);

// Test: KEEP
const keepChange = computeChange({
  desired: TestResource.build({ id: 'same', name: 'foo' }),
  remote: TestResource.build({ id: 'same', name: 'foo' }),
});
expect(keepChange.action).toBe(DeclastructChangeAction.KEEP);
expect(keepChange.state.difference).toBeNull();

// Test: UPDATE
const updateChange = computeChange({
  desired: TestResource.build({ id: 'same', name: 'new' }),
  remote: TestResource.build({ id: 'same', name: 'old' }),
});
expect(updateChange.action).toBe(DeclastructChangeAction.UPDATE);
expect(updateChange.state.difference).toBeTruthy();
```

---

### 4.3 Implement applyChange

**Dependencies:** 1.3, 1.4, 4.1

**Tasks:**
- [ ] Create `src/domain.operations/utils/applyChange.ts`
- [ ] Implement all 5 action handlers (KEEP, CREATE, UPDATE, DESTROY, REPLACE)
- [ ] Validate DAO supports operation before executing
- [ ] Return the change after applying

**Acceptance Criteria:**
- KEEP returns change without calling DAO
- CREATE calls `dao.set.findsert`
- UPDATE calls `dao.set.upsert` (fails if not supported)
- DESTROY calls `dao.set.delete` (fails if not supported)
- REPLACE calls delete then findsert
- Throws `UnexpectedCodePathError` for unknown actions

**Verification:**
```typescript
import { applyChange } from './domain.operations/utils/applyChange';

const mockDao = {
  get: { byUnique: jest.fn(), byRef: jest.fn() },
  set: {
    findsert: jest.fn(),
    upsert: jest.fn(),
    delete: jest.fn(),
  },
};

// Test: CREATE
await applyChange({
  change: createChange,
  providers: [{ name: 'test', daos: { TestResource: mockDao }, ... }],
});
expect(mockDao.set.findsert).toHaveBeenCalledWith(createChange.state.desired);

// Test: UPDATE without upsert support
const daoWithoutUpsert = { ...mockDao, set: { ...mockDao.set, upsert: undefined } };
await expect(applyChange({
  change: updateChange,
  providers: [{ name: 'test', daos: { TestResource: daoWithoutUpsert }, ... }],
})).rejects.toThrow('DAO does not support updates');
```

---

## Phase 5: Core Operations

### 5.1 Implement planChanges

**Dependencies:** 1.5, 1.6, 3.1, 4.1, 4.2

**Tasks:**
- [ ] Create `src/domain.operations/plan/changes.ts`
- [ ] Extract bottleneck from context
- [ ] Map over resources with bottleneck scheduling
- [ ] Fetch remote state via `dao.get.byUnique`
- [ ] Compute change for each resource
- [ ] Build and return plan with hash, timestamp, wish URI, and changes

**Acceptance Criteria:**
- Accepts resources, providers, and wishFilePath
- Uses bottleneck to control concurrency
- Returns plan with all changes
- Plan includes wish.uri
- Idempotent (calling multiple times with same input produces same plan)

**Verification:**
```typescript
import { planChanges } from './domain.operations/plan/changes';

const plan = await planChanges(
  {
    resources: [resource1, resource2],
    providers: [provider],
    wishFilePath: '/path/to/wish.ts',
  },
  {
    bottleneck: new Bottleneck({ maxConcurrent: 5 }),
    log: mockLogger,
  },
);

expect(plan.changes).toHaveLength(2);
expect(plan.wish.uri).toBe('/path/to/wish.ts');
expect(plan.hash).toBeTruthy();
expect(plan.createdAt).toMatch(/^\d{4}-\d{2}-\d{2}T/);

// Test idempotency
const plan2 = await planChanges(...sameInputs);
expect(plan.hash).toBe(plan2.hash);
```

---

### 5.2 Implement assertPlanStillValid

**Dependencies:** 1.6

**Tasks:**
- [ ] Create `src/domain.operations/plan/validate.ts`
- [ ] Compare original plan hash with current plan hash
- [ ] Throw `BadRequestError` if hashes differ

**Acceptance Criteria:**
- Passes when hashes match
- Throws with helpful context when hashes differ

**Verification:**
```typescript
import { assertPlanStillValid } from './domain.operations/plan/validate';

// Test: valid plan
assertPlanStillValid({
  originalPlan: plan1,
  currentPlan: plan1,
});
// Should not throw

// Test: stale plan
expect(() => assertPlanStillValid({
  originalPlan: plan1,
  currentPlan: plan2,
})).toThrow('plan is stale');
```

---

### 5.3 Implement applyChanges

**Dependencies:** 5.1, 5.2, 4.3

**Tasks:**
- [ ] Create `src/domain.operations/apply/changes.ts`
- [ ] Extract bottleneck from context
- [ ] Re-plan to validate plan is still valid
- [ ] Call `assertPlanStillValid`
- [ ] Iterate through changes sequentially
- [ ] Skip KEEP actions
- [ ] Apply each change and collect results
- [ ] Return applied changes

**Acceptance Criteria:**
- Re-plans before applying
- Validates plan hasn't changed
- Skips KEEP actions
- Applies changes sequentially (not parallel)
- Returns list of applied changes
- Idempotent (safe to rerun)

**Verification:**
```typescript
import { applyChanges } from './domain.operations/apply/changes';

const result = await applyChanges(
  { plan, providers },
  context,
);

expect(result.appliedChanges.length).toBeLessThanOrEqual(plan.changes.length);
// KEEP actions should be excluded

// Test idempotency - applying again should be safe
const result2 = await applyChanges({ plan, providers }, context);
// Should not throw or duplicate changes
```

---

## Phase 6: CLI Commands

### 6.1 Implement executePlanCommand

**Dependencies:** 5.1

**Tasks:**
- [ ] Create `src/contract/commands/plan.ts`
- [ ] Import wish file to get `getResources` and `getProviders`
- [ ] Initialize providers (call `beforeAll` hooks)
- [ ] Call `planChanges`
- [ ] Log each change with appropriate symbol
- [ ] Write plan JSON to file
- [ ] Cleanup providers (call `afterAll` hooks)
- [ ] Log summary

**Acceptance Criteria:**
- Loads wish file dynamically
- Initializes all providers before planning
- Cleans up all providers after planning
- Logs each change: `‚óã [ACTION] resource:Class:slug`
- KEEP actions show `‚Üì` symbol
- Writes valid JSON to plan file
- Shows summary with emoji and counts

**Verification:**
```bash
# Run command
npx tsx src/contract/commands/plan.ts \
  --wish ./test/fixtures/wish.ts \
  --plan ./test/fixtures/plan.json

# Verify output
# Should show:
# ‚óã [CREATE] resource:TestResource:test-1
# ‚Üì [KEEP] resource:TestResource:test-2
#
# üåä planned for 2 resources
#    into ./test/fixtures/plan.json

# Verify plan file exists and is valid JSON
cat ./test/fixtures/plan.json | jq .
```

---

### 6.2 Implement executeApplyCommand

**Dependencies:** 5.3

**Tasks:**
- [ ] Create `src/contract/commands/apply.ts`
- [ ] Load plan from file
- [ ] Import wish file from `plan.wish.uri`
- [ ] Initialize providers
- [ ] Apply changes with real-time logging
- [ ] Show `‚úî` for success, `‚Üì` for KEEP, `‚úñ` for errors
- [ ] Log errors before rethrowing
- [ ] Cleanup providers
- [ ] Log summary

**Acceptance Criteria:**
- Loads plan from JSON file
- Uses `plan.wish.uri` to load providers
- Initializes all providers before applying
- Logs each change as it's applied in real-time
- Success: `‚úî [CREATE] resource:Class:slug`
- Skip: `‚Üì [KEEP] resource:Class:slug`
- Error: `‚úñ [CREATE] resource:Class:slug` (then throws)
- Cleans up providers even after errors
- Shows summary with emoji

**Verification:**
```bash
# Run command
npx tsx src/contract/commands/apply.ts \
  --plan ./test/fixtures/plan.json

# Verify output shows real-time progress
# ‚úî [CREATE] resource:TestResource:test-1
# ‚Üì [KEEP] resource:TestResource:test-2
#
# üåä applied 1 changes

# Verify resources were actually created (integration test)
```

---

## Phase 7: SDK Exports

### 7.1 Create SDK Index

**Dependencies:** All domain objects

**Tasks:**
- [ ] Create `src/contract/sdk/index.ts`
- [ ] Export all domain objects
- [ ] Export all types (ContextDeclastruct, reference types, etc.)
- [ ] Export core operations (planChanges, applyChanges)

**Acceptance Criteria:**
- All public APIs are exported
- Can import from package root
- TypeScript types work correctly

**Verification:**
```typescript
import {
  DeclastructChange,
  DeclastructChangeAction,
  DeclastructDao,
  DeclastructProvider,
  DeclastructPlan,
  IsoTimestamp,
  ContextDeclastruct,
  planChanges,
  applyChanges,
} from 'declastruct';

// All imports should work
```

---

## Phase 8: Integration Testing

### 8.1 Create In-Memory Test Provider

**Dependencies:** 1.4, 1.5

**Tasks:**
- [ ] Create `src/.test/fixtures/InMemoryProvider.ts`
- [ ] Implement in-memory DAOs for test resources
- [ ] Support all DAO operations (get, findsert, upsert, delete)
- [ ] Track state in memory

**Acceptance Criteria:**
- Implements `DeclastructProvider` interface
- Supports all CRUD operations
- State persists across operations within same instance
- Can be reset between tests

**Verification:**
```typescript
const provider = createInMemoryProvider();
const dao = provider.daos['TestResource'];

// Create
const created = await dao.set.findsert(resource);
expect(created).toBeDefined();

// Read
const found = await dao.get.byUnique(resource);
expect(found).toEqual(resource);

// Update
const updated = await dao.set.upsert(resource.clone({ name: 'new' }));
expect(updated.name).toBe('new');

// Delete
await dao.set.delete(resource);
const deleted = await dao.get.byUnique(resource);
expect(deleted).toBeNull();
```

---

### 8.2 Full Plan-Apply Cycle Test

**Dependencies:** 8.1, All phases

**Tasks:**
- [ ] Create integration test for complete workflow
- [ ] Define test resources
- [ ] Create wish file
- [ ] Execute plan command
- [ ] Verify plan output
- [ ] Execute apply command
- [ ] Verify resources created/updated
- [ ] Re-apply to verify idempotency

**Acceptance Criteria:**
- Plan shows correct changes
- Apply creates all resources
- Re-apply is idempotent (no errors, no duplicate creates)
- Plan after apply shows all KEEP

**Verification:**
```typescript
// Plan initial resources
const plan1 = await planChanges({ resources: initialResources, providers, wishFilePath });
expect(plan1.changes.filter(c => c.action === 'CREATE')).toHaveLength(3);

// Apply
await applyChanges({ plan: plan1, providers }, context);

// Verify resources exist
const resource1 = await provider.daos['TestResource'].get.byUnique(initialResources[0]);
expect(resource1).toBeDefined();

// Plan again - should show all KEEP
const plan2 = await planChanges({ resources: initialResources, providers, wishFilePath });
expect(plan2.changes.filter(c => c.action === 'KEEP')).toHaveLength(3);
expect(plan2.changes.filter(c => c.action === 'CREATE')).toHaveLength(0);

// Apply again - should be idempotent
await applyChanges({ plan: plan2, providers }, context);
// Should not throw
```

---

## Phase 9: Documentation

### 9.1 API Documentation

**Dependencies:** 7.1

**Tasks:**
- [ ] Document all exported types
- [ ] Document all exported functions
- [ ] Add usage examples
- [ ] Document provider contract

**Acceptance Criteria:**
- Every export has JSDoc comments
- Examples compile and run
- Provider implementation guide is clear

**Verification:**
```bash
# Generate docs
npm run docs

# Verify all exports are documented
# Verify examples work
```

---

### 9.2 Example Provider

**Dependencies:** All phases

**Tasks:**
- [ ] Create example provider in docs or examples folder
- [ ] Implement simple provider (e.g., file-based)
- [ ] Show complete implementation
- [ ] Add to documentation

**Acceptance Criteria:**
- Example provider implements full interface
- Includes comments explaining each part
- Can be used as template for real providers

**Verification:**
```bash
# Run example
cd examples/file-provider
npm test
# Should pass
```

---

## Completion Checklist

**Phase 1:** ‚òê All domain objects implemented and tested
**Phase 2:** ‚òê Reference type system complete
**Phase 3:** ‚òê Context types defined
**Phase 4:** ‚òê Supporting operations implemented
**Phase 5:** ‚òê Core operations (plan/apply) working
**Phase 6:** ‚òê CLI commands functional
**Phase 7:** ‚òê SDK properly exported
**Phase 8:** ‚òê Integration tests passing
**Phase 9:** ‚òê Documentation complete

---

## Success Criteria

The implementation is complete when:

1. ‚úÖ All unit tests pass
2. ‚úÖ Integration test demonstrates full plan ‚Üí apply ‚Üí re-plan ‚Üí re-apply cycle
3. ‚úÖ CLI commands work end-to-end
4. ‚úÖ Example provider exists and is documented
5. ‚úÖ No `any` types in public API
6. ‚úÖ All code follows mechanic style briefs (immutability, fail-fast, arrow functions, comments)
7. ‚úÖ TypeScript compiles with no errors
8. ‚úÖ ESLint passes with project rules
