emit your response into .behaviors/v2025_11_21.contract/5.1.execution.phase6.v1.[feedback].v4.[taken].by_robot.md

=====

bootup your mechanic's role via `npx rhachet roles boot --repo ehmpathy --role mechanic`

then respond to the feedback below


=====

# blocker.0

add unit or integration tests against all of the src/domain.operations. seeing no tests at all right now :(
- use a unit test if it has no dependencies
- use an integration tests if it does have dependencies, to avoid need to mock

=====


# blocker.1

instead of saying "not supported", implement a demo provider that has on disk persistence; have it persist resources on disk in the `.test/demo/provider/.temp` dir

e.g., fix this and all others that should test creates + updates + deletes

  it('should detect KEEP action when resource already exists remotely', async () => {
    // first run - create resources
    await executePlanCommand({ wishFilePath, planFilePath });

    // read first plan
    const firstPlanJson = await readFile(planFilePath, 'utf-8');
    const firstPlan = new DeclastructPlan(JSON.parse(firstPlanJson));

    // verify all CREATE
    expect(firstPlan.changes.every((c) => c.action === 'CREATE')).toBe(true);

    // cleanup and run again
    await rm(planFilePath);

    // Note: In a real integration test, we would need to actually apply the changes
    // to populate remote state. For now, this test just verifies the basic flow.
    // A more complete test would require mocking or actual provider state.
  });



=====


# blocker.2

we want to emit logs per resource as we process each resource; not do all applies in silence and then report everything

move the logs into `applyChanges` directly; (do the same for planChanges, too)


ref: src/contract/cli/apply.ts


  const appliedChanges: any[] = [];

  const result = await applyChanges({ plan, providers }, context);

  // log each applied change in real-time
  result.appliedChanges.forEach((change) => {
    const symbol = 'âœ”';
    const className = change.forResource.class;
    const slug = change.forResource.slug;

    log.info(`${symbol} [${change.action}] ${className}:${slug}`);
    appliedChanges.push(change);
  });

  // log skipped KEEP actions
  plan.changes.forEach((change) => {
    if (change.action === DeclastructChangeAction.KEEP) {
      const className = change.forResource.class;
      const slug = change.forResource.slug;

      log.info(`â†“ [KEEP] ${className}:${slug}`);
    }
  });


===========


# blocker.3

we need a global

bin/run


to ensure that it is invokable

e.g.,


```
#!/usr/bin/env tsx
import { invoke } from '../dist/contract/cli/invoke';

void invoke({ args: process.argv.slice(2) });
```


this `invoke({})` should then call a `dist/contract/cli/invoke` which executes the compiled `src/contract/cli/invoke`

which runs a global invoke command that supports

npx declastruct --version
npx declastruct --help
npx declastruct plan --wish $wish --into $into
npx declastruct apply --plan $plan

use import { Command } from 'commander';

have it leverage the `executePlanCommand` and `executeApplyCommand` procedures you've added already

drop the


// run if called directly
if (require.main === module) {
  const args = process.argv.slice(2);
  const planIndex = args.indexOf('--plan');

  if (planIndex === -1) {
    console.error('Usage: apply --plan <plan-file>');
    process.exit(1);
  }

  const planFilePath = args[planIndex + 1];

  if (!planFilePath) {
    console.error('Usage: apply --plan <plan-file>');
    process.exit(1);
  }

  executeApplyCommand({ planFilePath })
    .then(() => {
      process.exit(0);
    })
    .catch((error) => {
      log.error('âœ– Error during apply:', error);
      process.exit(1);
    });
}


# blocker.4

no __test_assets__ dirs

everything goes into `.test/assets` as the modern pattern


# blocker.5

on create, the diff should show all the attributes. maybe pass in `{}` into the diff checker?

today getting
        "difference": "  Comparing two different types of values. Expected [32mnull[39m but received [31mobject[39m.",
