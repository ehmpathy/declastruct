# Blueprint: Declarative Delete Support

## Overview

Enable users to declaratively mark resources for deletion using a `del()` wrapper function, which will trigger the existing `DESTROY` action during plan/apply.

## Current State Analysis

The infrastructure for deletion **already exists**:
- `DeclastructChangeAction.DESTROY` is defined in `src/domain.objects/DeclastructChange.ts`
- `dao.set.delete` is defined in `src/domain.objects/DeclastructDao.ts:139-141`
- `computeChange()` returns `DESTROY` when `desired=null` (line 49 of `computeChange.ts`)
- `applyChange()` handles `DESTROY` by calling `dao.set.delete()` (exists in `applyChange.ts`)

**What's missing**: A mechanism to mark resources as "to be deleted" when they are returned from `getResources()`.

## Proposed Solution

### 1. Define the Delete Marker Symbol

Create a new file `src/domain/symbols.ts`:

```ts
/**
 * .what = symbol used to mark resources for declarative deletion
 * .why = enables del() wrapper to mark resources without polluting their interface
 */
export const DECLASTRUCT_DELETE = Symbol.for('declastruct.delete');
```

### 2. Create the `del()` Helper Function

Create a new file `src/domain.operations/del/del.ts`:

```ts
import type { DeclaredResource } from '../../domain.objects/DeclaredResource';
import { DECLASTRUCT_DELETE } from '../../domain/symbols';

/**
 * .what = marks a resource for deletion in declarative infrastructure
 * .why = enables users to express deletion intent without null manipulation
 *
 * .how = attaches a symbol-keyed property to the resource object
 *
 * @example
 * ```ts
 * const getResources = async () => {
 *   const tokens = await getAllIamAuthTokens(...);
 *   return tokens.map(token => del(token)); // mark all for deletion
 * }
 * ```
 */
export const del = <T extends DeclaredResource>(
  resource: T,
): T & { [DECLASTRUCT_DELETE]: true } => {
  return Object.assign(resource, { [DECLASTRUCT_DELETE]: true as const });
};

/**
 * .what = checks if a resource is marked for deletion
 * .why = enables planChanges to detect deletion intent
 * .note = type guard narrows to the marked type for downstream type safety
 */
export const isMarkedForDeletion = <T extends DeclaredResource>(
  resource: T,
): resource is T & { [DECLASTRUCT_DELETE]: true } => {
  return (resource as any)[DECLASTRUCT_DELETE] === true;
};
```

### 3. Update `planChanges.ts` to Handle Deletion Markers

In `src/domain.operations/plan/planChanges.ts`, modify the planning logic:

```ts
import { isMarkedForDeletion } from '../../domain.objects/del';

// Inside the for loop, after extracting DAO:
const desiredState = isMarkedForDeletion(resource) ? null : resource;

// compute change with conditional desired state
const computed = computeChange({
  desired: desiredState,
  remote: remoteState,
});
```

### 4. Export from SDK

Update `src/contract/sdk/index.ts` to export the new helper:

```ts
// domain operations
export { del, isMarkedForDeletion } from '../../domain.operations/del/del';
```

### 5. Update `src/domain/constants.ts` or Create `src/domain/symbols.ts`

Add the symbol constant. Since `constants.ts` exists but is empty, either:
- Add to existing `constants.ts`
- Create new `symbols.ts` for semantic clarity

Recommendation: Create `src/domain/symbols.ts` for clarity.

## Data Flow

```
User's getResources()
        │
        ▼
    del(resource)  ──────► resource[DECLASTRUCT_DELETE] = true
        │
        ▼
    planChanges()
        │
        ├─► isMarkedForDeletion(resource)?
        │       │
        │       ├─ true  ──► desired = null
        │       └─ false ──► desired = resource
        │
        ▼
    computeChange({ desired, remote })
        │
        ├─ desired=null, remote exists ──► DESTROY
        └─ ... other actions unchanged
        │
        ▼
    applyChange()
        │
        └─ DESTROY ──► dao.set.delete(remote, context)
```

## Files to Create

| File | Purpose |
|------|---------|
| `src/domain/symbols.ts` | Define `DECLASTRUCT_DELETE` symbol |
| `src/domain.operations/del/del.ts` | `del()` and `isMarkedForDeletion()` helpers |
| `src/domain.operations/del/del.test.ts` | Unit tests for del helpers |
| `src/.test/assets/wish-for-del.fixture.ts` | Template fixture: creates resource (placeholder `__TEST_EXID__`) |
| `src/.test/assets/wish-with-del.fixture.ts` | Template fixture: del() marks resource (placeholder `__TEST_EXID__`) |

## Files to Modify

| File | Change |
|------|--------|
| `src/domain.operations/plan/planChanges.ts` | Import and use `isMarkedForDeletion()` |
| `src/contract/sdk/index.ts` | Export `del` and `isMarkedForDeletion` |
| `src/contract/cli/plan.integration.test.ts` | Add integration test for `del()` planning DESTROY |
| `src/contract/cli/apply.integration.test.ts` | Add integration tests for `del()` apply and yolo mode |

## Test Strategy

### Unit Tests for `del.ts`

```ts
describe('del', () => {
  it('should mark resource for deletion', () => {
    const resource = new DemoResource({ id: '1', name: 'test' });
    const marked = del(resource);
    expect(isMarkedForDeletion(marked)).toBe(true);
  });

  it('should preserve original resource properties', () => {
    const resource = new DemoResource({ id: '1', name: 'test' });
    const marked = del(resource);
    expect(marked.id).toBe('1');
    expect(marked.name).toBe('test');
  });

  it('should return false for unmarked resources', () => {
    const resource = new DemoResource({ id: '1', name: 'test' });
    expect(isMarkedForDeletion(resource)).toBe(false);
  });
});
```

### Integration Tests for planChanges

```ts
it('should plan DESTROY for resources marked with del()', async () => {
  const resource = del(new DemoResource({ id: '1', name: 'test' }));
  const remoteState = new DemoResource({ id: '1', name: 'test' });

  // mock dao to return the remote state
  mockDao.get.one.byUnique.mockResolvedValue(remoteState);

  const plan = await planChanges({ resources: [resource], ... });

  expect(plan.changes[0].action).toBe(DeclastructChangeAction.DESTROY);
  expect(plan.changes[0].state.desired).toBeNull();
  expect(plan.changes[0].state.remote).toEqual(remoteState);
});
```

### CLI Integration Tests

Create template fixture files that use a placeholder exid. Each test clones these into its isolated temp directory and replaces the placeholder with a unique test-scoped exid.

**`src/.test/assets/wish-for-del.fixture.ts`** (template):
```ts
import type { DomainEntity } from 'domain-objects';

import type { DeclastructProvider } from '../../domain.objects/DeclastructProvider';
import { DemoResource, demoProvider } from './providers/demo.provider';

/**
 * .what = template wish file that creates a resource
 * .note = uses placeholder exid '__TEST_EXID__' to be replaced per-test
 */
export const getResources = async (): Promise<DomainEntity<any>[]> => {
  return [
    DemoResource.as({ exid: '__TEST_EXID__', name: 'To Be Deleted' }),
  ];
};

export const getProviders = async (): Promise<DeclastructProvider<any, any>[]> => {
  return [demoProvider];
};

export { DemoResource };
```

**`src/.test/assets/wish-with-del.fixture.ts`** (template):
```ts
import type { DomainEntity } from 'domain-objects';

import type { DeclastructProvider } from '../../domain.objects/DeclastructProvider';
import { del } from '../../domain.operations/del/del';
import { DemoResource, demoProvider } from './providers/demo.provider';

/**
 * .what = template wish file that marks a resource for deletion
 * .note = uses placeholder exid '__TEST_EXID__' to be replaced per-test
 */
export const getResources = async (): Promise<DomainEntity<any>[]> => {
  return [
    del(DemoResource.as({ exid: '__TEST_EXID__', name: 'To Be Deleted' })),
  ];
};

export const getProviders = async (): Promise<DeclastructProvider<any, any>[]> => {
  return [demoProvider];
};

export { DemoResource };
```

**Test helper** (add to test files or shared test utils):
```ts
/**
 * .what = clones a fixture file into temp dir with unique exid
 * .why = enables parallel test execution without race conditions
 */
const cloneFixtureWithExid = async (
  fixturePath: string,
  tempDir: string,
  exid: string,
): Promise<string> => {
  const content = await readFile(fixturePath, 'utf-8');
  const replaced = content.replace(/__TEST_EXID__/g, exid);
  const targetPath = resolve(tempDir, path.basename(fixturePath));
  await writeFile(targetPath, replaced, 'utf-8');
  return targetPath;
};
```

Add tests to `src/contract/cli/plan.integration.test.ts`:

```ts
it('should plan DESTROY for resources marked with del()', async () => {
  const tempDir = await genTempDir();
  const testExid = getUuid();
  const planFilePath = resolve(tempDir, 'plan.json');

  // clone fixtures with test-scoped exid
  const setupWishFilePath = await cloneFixtureWithExid(
    resolve(process.cwd(), 'src/.test/assets/wish-for-del.fixture.ts'),
    tempDir,
    testExid,
  );
  const delWishFilePath = await cloneFixtureWithExid(
    resolve(process.cwd(), 'src/.test/assets/wish-with-del.fixture.ts'),
    tempDir,
    testExid,
  );

  // step 1: create resource first
  await executePlanCommand({ wishFilePath: setupWishFilePath, planFilePath });
  await executeApplyCommand({ planFilePath });

  // step 2: plan with del() - should show DESTROY
  await executePlanCommand({ wishFilePath: delWishFilePath, planFilePath });

  // read and verify plan
  const planJson = await readFile(planFilePath, 'utf-8');
  const plan = new DeclastructPlan(JSON.parse(planJson));

  expect(plan.changes.length).toBe(1);
  expect(plan.changes[0].action).toBe('DESTROY');
  expect(plan.changes[0].state.desired).toBeNull();
  expect(plan.changes[0].state.remote).toBeDefined();
});
```

Add tests to `src/contract/cli/apply.integration.test.ts`:

```ts
describe('del() support', () => {
  it('should apply DESTROY action for resources marked with del()', async () => {
    const tempDir = await genTempDir();
    const testExid = getUuid();
    const planFilePath = resolve(tempDir, 'plan.json');

    // clone fixtures with test-scoped exid
    const setupWishFilePath = await cloneFixtureWithExid(
      resolve(process.cwd(), 'src/.test/assets/wish-for-del.fixture.ts'),
      tempDir,
      testExid,
    );
    const delWishFilePath = await cloneFixtureWithExid(
      resolve(process.cwd(), 'src/.test/assets/wish-with-del.fixture.ts'),
      tempDir,
      testExid,
    );

    // step 1: create resource first
    await executePlanCommand({ wishFilePath: setupWishFilePath, planFilePath });
    await executeApplyCommand({ planFilePath });

    // step 2: plan and apply deletion
    await executePlanCommand({ wishFilePath: delWishFilePath, planFilePath });

    const planJson = await readFile(planFilePath, 'utf-8');
    const plan = new DeclastructPlan(JSON.parse(planJson));
    expect(plan.changes[0].action).toBe('DESTROY');

    // apply deletion
    await executeApplyCommand({ planFilePath });

    // step 3: verify resource is gone - plan again without del()
    await executePlanCommand({ wishFilePath: setupWishFilePath, planFilePath });

    const verifyPlanJson = await readFile(planFilePath, 'utf-8');
    const verifyPlan = new DeclastructPlan(JSON.parse(verifyPlanJson));

    // should need to CREATE again since resource was deleted
    expect(verifyPlan.changes[0].action).toBe('CREATE');
  });

  it('should handle del() in yolo mode', async () => {
    const tempDir = await genTempDir();
    const testExid = getUuid();

    // clone fixtures with test-scoped exid
    const setupWishFilePath = await cloneFixtureWithExid(
      resolve(process.cwd(), 'src/.test/assets/wish-for-del.fixture.ts'),
      tempDir,
      testExid,
    );
    const delWishFilePath = await cloneFixtureWithExid(
      resolve(process.cwd(), 'src/.test/assets/wish-with-del.fixture.ts'),
      tempDir,
      testExid,
    );

    // step 1: create resource in yolo mode
    await executeApplyCommand({ planFilePath: 'yolo', wishFilePath: setupWishFilePath });

    // step 2: delete in yolo mode using del()
    const logSpy = jest.spyOn(console, 'info');

    await executeApplyCommand({ planFilePath: 'yolo', wishFilePath: delWishFilePath });

    // verify DESTROY was logged
    const logCalls = logSpy.mock.calls.map((call) => call.join(' '));
    expect(logCalls.some((log) => log.includes('DESTROY'))).toBe(true);

    logSpy.mockRestore();
  });
});
```

## Edge Cases to Handle

1. **del() on non-existent resource**: If `del(resource)` is called but resource doesn't exist remotely, `computeChange({ desired: null, remote: null })` would need to handle this. Currently this path isn't explicitly handled - should return `KEEP` or throw.

2. **Multiple del() calls**: `del(del(resource))` should be idempotent - already handled since we just set a boolean.

3. **Serialization**: When plan is serialized to JSON, the symbol-keyed property won't be included. This is fine since the desired state is already set to `null` in the change record.

## Implementation Order

1. Create `src/domain/symbols.ts` with `DECLASTRUCT_DELETE`
2. Create `src/domain.operations/del/del.ts` with `del()` and `isMarkedForDeletion()`
3. Create `src/domain.operations/del/del.test.ts` with unit tests
4. Modify `src/domain.operations/plan/planChanges.ts` to use `isMarkedForDeletion()`
5. Add integration test for del() in `src/domain.operations/plan/planChanges.integration.test.ts`
6. Export from `src/contract/sdk/index.ts`
7. Add CLI integration tests to `src/contract/cli/plan.integration.test.ts`
8. Add CLI integration tests to `src/contract/cli/apply.integration.test.ts`
9. Run full test suite to verify no regressions

## Alternative Considered

**Alternative**: Use a wrapper type instead of symbol mutation

```ts
type DeletedResource<T> = { __deleted: true; resource: T };
```

**Rejected because**:
- Would require changing the signature of `getResources()` to return union type
- Would complicate type inference throughout the system
- Symbol approach is more transparent and preserves resource identity

## Notes

- The symbol uses `Symbol.for('declastruct.delete')` (global registry) for consistency and debuggability
- The `del()` function mutates in place for ergonomics but could be pure with `Object.assign({}, resource, { ... })`
- Since `computeChange` already handles `desired=null` → `DESTROY`, no changes needed there
- Since `applyChange` already handles `DESTROY` → `dao.set.delete()`, no changes needed there
