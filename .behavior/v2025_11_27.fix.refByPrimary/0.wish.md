wish =

we can declare Resources which have an optional (metadata) primary key

e.g.,

```ts
import { DomainEntity, DomainLiteral } from 'domain-objects';

/**
 * .what = endpoint specification for port forwarding
 * .why = reusable structure for source and target endpoints
 */
export interface UnixPortEndpoint {
  host: string;
  port: number;
}

export class UnixPortEndpoint
  extends DomainLiteral<UnixPortEndpoint>
  implements UnixPortEndpoint {}

/**
 * .what = a declarative structure which represents a unix port alias (port forwarding)
 * .why = enables declarative management of systemd-socat services following declastruct patterns
 */
export interface DeclaredUnixPortAlias {
  /**
   * .what = systemd service unit file path
   * .note = @metadata -> only known after persistence, autogenerated
   */
  uri?: string;

  /**
   * .what = mechanism used to manage the port forwarding
   * .note = currently only 'systemd-socat' is supported
   */
  via: 'systemd-socat';

  /**
   * .what = source endpoint to listen on
   */
  from: UnixPortEndpoint;

  /**
   * .what = target endpoint to forward to
   */
  into: UnixPortEndpoint;
}

export class DeclaredUnixPortAlias
  extends DomainEntity<DeclaredUnixPortAlias>
  implements DeclaredUnixPortAlias
{
  public static primary = ['uri'] as const;
  public static unique = ['via', 'from'] as const;
  public static nested = {
    from: UnixPortEndpoint,
    into: UnixPortEndpoint,
  };
}
```


---

the dao should support get: { byPrimary: RefByPrimary<typeof DeclaredUnixPortAlias> }


where RefByPrimary<typeof DeclaredUnixPortAlias> has ap rimary key ref that may not always be known, but will be required on RefByPrimary


---

right now the types look ilke they should work

but we need to

1. verify via integration + unit tests


---

the WISH = we have explicit integration tests coverage for a resource with this shape && prove getByPrimary via dao works well
