# blueprint: RefByPrimary with optional metadata primary key

## context

the wish is to verify and prove that `RefByPrimary<typeof Resource>` works correctly for resources where the primary key is optional metadata (e.g., `uri?: string`).

the concern is that when a domain entity has:
```ts
public static primary = ['uri'] as const;
```

but the interface declares:
```ts
uri?: string;
```

we need to ensure:
1. `RefByPrimary<typeof DeclaredUnixPortAlias>` correctly requires `{ uri: string }` (non-optional)
2. `get.byPrimary({ uri })` works in the dao pattern
3. `get.byRef(ref)` correctly dispatches to `byPrimary` vs `byUnique`

---

## analysis

from `domain-objects` types:
- `RefByPrimary<TDobj>` = `Pick<InstanceType<TDobj>, RefKeysPrimary<TDobj>[number]>`
- `RefKeysPrimary<TDobj>` = `TDobj['primary']`
- importantly: `Ref<TDobj>` uses `Required<RefByPrimary<...>>` which forces optional keys to be required

so the types *should* work correctly — `RefByPrimary` will pick the `uri` property, and when used in `Ref`, it becomes `Required<{ uri?: string }>` = `{ uri: string }`.

---

## implementation plan

### step 1: create test fixture with optional-primary resource

create a new provider fixture at `src/.test/assets/providers/demo-with-optional-primary.provider.ts`:

```ts
interface DeclaredUnixPortAlias {
  uri?: string;  // metadata primary key, only known after persistence
  via: 'systemd-socat';
  from: UnixPortEndpoint;
  into: UnixPortEndpoint;
}

class DeclaredUnixPortAlias extends DomainEntity<DeclaredUnixPortAlias> {
  public static primary = ['uri'] as const;
  public static unique = ['via', 'from'] as const;  // compound unique key
  public static nested = { from: UnixPortEndpoint, into: UnixPortEndpoint };
}
```

the dao should:
- implement `get.byUnique({ via, from })`
- implement `get.byPrimary({ uri })` — note: uri is required in the ref type
- implement `get.byRef(ref)` — dispatches based on ref shape
- implement `set.findsert(resource)` — assigns uri on creation

### step 2: add unit tests for type correctness

in `src/domain.objects/DeclastructDao.test.ts`, add type-level tests:

```ts
describe('resource with optional primary key', () => {
  interface DemoResourceWithOptionalPrimary {
    uuid?: string;  // optional in instance, metadata primary key
    name: string;
  }
  class DemoResourceWithOptionalPrimary extends DomainEntity<...> {
    public static primary = ['uuid'] as const;
    public static unique = ['name'] as const;
  }

  it('RefByPrimary should require uuid (not optional)', () => {
    // type test: this should compile
    const ref: RefByPrimary<typeof DemoResourceWithOptionalPrimary> = { uuid: 'test' };

    // @ts-expect-error - uuid should be required
    const badRef: RefByPrimary<typeof DemoResourceWithOptionalPrimary> = {};
  });

  it('dao.get.byPrimary should accept RefByPrimary', () => {
    const dao: DeclastructDao<DemoResourceWithOptionalPrimary, typeof DemoResourceWithOptionalPrimary> = {
      get: {
        byUnique: async () => null,
        byPrimary: async (input) => {
          // input.uuid should be string (not string | undefined)
          const uuid: string = input.uuid;
          return null;
        },
        byRef: async () => null,
      },
      set: { findsert: async (r) => r as any },
    };
  });
});
```

### step 3: add integration tests for runtime behavior

create `src/domain.objects/RefByPrimary.integration.test.ts`:

```ts
describe('RefByPrimary with optional metadata primary key', () => {
  given('a resource with optional primary key (uuid)', () => {
    // setup provider with DemoResourceWithOptionalPrimary

    when('resource is created without uuid', () => {
      then('findsert should assign uuid and return it', async () => {
        const resource = new DemoResourceWithOptionalPrimary({ name: 'test' });
        const saved = await dao.set.findsert(resource, {});
        expect(saved.uuid).toBeDefined();
      });
    });

    when('resource exists with uuid', () => {
      then('get.byPrimary({ uuid }) should find it', async () => {
        const found = await dao.get.byPrimary({ uuid: saved.uuid }, {});
        expect(found).toEqual(saved);
      });

      then('get.byUnique({ name }) should find it', async () => {
        const found = await dao.get.byUnique({ name: 'test' }, {});
        expect(found).toEqual(saved);
      });

      then('get.byRef with primary ref should find it', async () => {
        const found = await dao.get.byRef({ uuid: saved.uuid }, {});
        expect(found).toEqual(saved);
      });

      then('get.byRef with unique ref should find it', async () => {
        const found = await dao.get.byRef({ name: 'test' }, {});
        expect(found).toEqual(saved);
      });
    });
  });
});
```

---

## files to create/modify

| action | path | purpose |
|--------|------|---------|
| create | `src/.test/assets/providers/demo-with-optional-primary.provider.ts` | test fixture with optional primary key |
| modify | `src/domain.objects/DeclastructDao.test.ts` | add type-level tests |
| create | `src/domain.objects/RefByPrimary.integration.test.ts` | runtime behavior tests |

---

## success criteria

1. ✅ type tests compile without errors
2. ✅ `RefByPrimary<typeof Resource>` requires the primary key (not optional)
3. ✅ `get.byPrimary({ uri })` correctly fetches by primary key
4. ✅ `get.byRef(ref)` correctly dispatches to byPrimary vs byUnique
5. ✅ `set.findsert` can assign uri metadata on creation
6. ✅ all integration tests pass with THOROUGH=true

---

## risk assessment

**low risk** — this is primarily a verification task:
- domain-objects types already support this pattern via `Required<RefByPrimary<...>>`
- declastruct dao interface already has optional `byPrimary`
- no production code changes needed, only test additions

**potential issue**: if `isUniqueKeyRef` / `isPrimaryKeyRef` helpers don't exist or work correctly, `byRef` dispatch logic may need custom implementation. should verify these exist in domain-objects.
